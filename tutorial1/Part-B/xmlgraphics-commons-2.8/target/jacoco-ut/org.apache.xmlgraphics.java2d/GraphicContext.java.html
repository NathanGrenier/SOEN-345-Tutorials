<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphicContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">org.apache.xmlgraphics:xmlgraphics-commons</a> &gt; <a href="index.source.html" class="el_package">org.apache.xmlgraphics.java2d</a> &gt; <span class="el_source">GraphicContext.java</span></div><h1>GraphicContext.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* $Id: GraphicContext.java 1732018 2016-02-24 04:51:06Z gadams $ */

package org.apache.xmlgraphics.java2d;

import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Font;
import java.awt.Paint;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.font.FontRenderContext;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.NoninvertibleTransformException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

// CSOFF: OperatorWrap
// CSOFF: ParameterName
// CSOFF: WhitespaceAround

/**
 * Handles the attributes in a graphic context:&lt;br&gt;
 * + Composite &lt;br&gt;
 * + Font &lt;br&gt;
 * + Paint &lt;br&gt;
 * + Stroke &lt;br&gt;
 * + Clip &lt;br&gt;
 * + RenderingHints &lt;br&gt;
 * + AffineTransform &lt;br&gt;
 *
 * @version $Id: GraphicContext.java 1732018 2016-02-24 04:51:06Z gadams $
 *
 * Originally authored by Vincent Hardy and Christophe Jolif.
 */
public class GraphicContext implements Cloneable {
    /**
     * Default Transform to be used for creating FontRenderContext.
     */
<span class="fc" id="L63">    protected AffineTransform defaultTransform = new AffineTransform();</span>

    /**
     * Current AffineTransform. This is the concatenation
     * of the original AffineTransform (i.e., last setTransform
     * invocation) and the following transform invocations,
     * as captured by originalTransform and the transformStack.
     */
<span class="fc" id="L71">    protected AffineTransform transform = new AffineTransform();</span>

    /**
     * Transform stack
     */
<span class="fc" id="L76">    protected List transformStack = new ArrayList();</span>

    /**
     * Defines whether the transform stack is valid or not.
     * This is for use by the class clients. The client should
     * validate the stack every time it starts using it. The
     * stack becomes invalid when a new transform is set.
     * @see #invalidateTransformStack()
     * @see #isTransformStackValid
     * @see #setTransform
     */
<span class="fc" id="L87">    protected boolean transformStackValid = true;</span>

    /**
     * Current Paint
     */
<span class="fc" id="L92">    protected Paint paint = Color.black;</span>

    /**
     * Current Stroke
     */
<span class="fc" id="L97">    protected Stroke stroke = new BasicStroke();</span>

    /**
     * Current Composite
     */
<span class="fc" id="L102">    protected Composite composite = AlphaComposite.SrcOver;</span>

    /**
     * Current clip
     */
    protected Shape clip;

    /**
     * Current set of RenderingHints
     */
<span class="fc" id="L112">    protected RenderingHints hints = new RenderingHints(null);</span>

    /**
     * Current Font
     */
<span class="fc" id="L117">    protected Font font = new Font(&quot;sanserif&quot;, Font.PLAIN, 12);</span>

    /**
     * Current background color.
     */
<span class="fc" id="L122">    protected Color background = new Color(0, 0, 0, 0);</span>

    /**
     * Current foreground color
     */
<span class="fc" id="L127">    protected Color foreground = Color.black;</span>

    /**
     * Default constructor
     */
<span class="fc" id="L132">    public GraphicContext() {</span>
        // to workaround a JDK bug
<span class="fc" id="L134">        hints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_DEFAULT);</span>
<span class="fc" id="L135">    }</span>

    /**
     * @param defaultDeviceTransform Default affine transform applied to map the user space to the
     *                               user space.
     */
    public GraphicContext(AffineTransform defaultDeviceTransform) {
<span class="nc" id="L142">        this();</span>
<span class="nc" id="L143">        defaultTransform = new AffineTransform(defaultDeviceTransform);</span>
<span class="nc" id="L144">        transform = new AffineTransform(defaultTransform);</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (!defaultTransform.isIdentity()) {</span>
<span class="nc" id="L146">            transformStack.add(TransformStackElement.createGeneralTransformElement(defaultTransform));</span>
        }
<span class="nc" id="L148">    }</span>

    /**
     * Copy constructor.
     * @param template the instance to make a copy of
     */
    protected GraphicContext(GraphicContext template) {
<span class="nc" id="L155">        this(template.defaultTransform);</span>
        //
        // Now, copy each GC element in turn
        //

        // Default transform
        /* Set in constructor */

        // Transform
<span class="nc" id="L164">        this.transform = new AffineTransform(template.transform);</span>

        // Transform stack
<span class="nc" id="L167">        this.transformStack = new ArrayList(template.transformStack.size());</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        for (int i = 0; i &lt; template.transformStack.size(); i++) {</span>
<span class="nc" id="L169">            TransformStackElement stackElement</span>
<span class="nc" id="L170">                = (TransformStackElement)template.transformStack.get(i);</span>
<span class="nc" id="L171">            this.transformStack.add(stackElement.clone());</span>
        }

        // Transform stack validity
<span class="nc" id="L175">        this.transformStackValid = template.transformStackValid;</span>

        // Paint (immutable by requirement)
<span class="nc" id="L178">        this.paint = template.paint;</span>

        // Stroke (immutable by requirement)
<span class="nc" id="L181">        this.stroke = template.stroke;</span>

        // Composite (immutable by requirement)
<span class="nc" id="L184">        this.composite = template.composite;</span>

        // Clip
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (template.clip != null) {</span>
<span class="nc" id="L188">            this.clip = new GeneralPath(template.clip);</span>
        } else {
<span class="nc" id="L190">            this.clip = null;</span>
        }

        // RenderingHints
<span class="nc" id="L194">        this.hints = (RenderingHints)template.hints.clone();</span>

        // Font (immutable)
<span class="nc" id="L197">        this.font = template.font;</span>

        // Background, Foreground (immutable)
<span class="nc" id="L200">        this.background = template.background;</span>
<span class="nc" id="L201">        this.foreground = template.foreground;</span>
<span class="nc" id="L202">    }</span>

    /**
     * @return a deep copy of this context
     */
    public Object clone() {
<span class="nc" id="L208">        return new GraphicContext(this);</span>
    }

    /**
     * Gets this graphics context's current color.
     * @return    this graphics context's current color.
     * @see       java.awt.Color
     * @see       java.awt.Graphics#setColor
     */
    public Color getColor() {
<span class="fc" id="L218">        return foreground;</span>
    }

    /**
     * Sets this graphics context's current color to the specified
     * color. All subsequent graphics operations using this graphics
     * context use this specified color.
     * @param     c   the new rendering color.
     * @see       java.awt.Color
     * @see       java.awt.Graphics#getColor
     */
    public void setColor(Color c) {
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L231">            return;</span>
        }

<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (paint != c) {</span>
<span class="nc" id="L235">            setPaint(c);</span>
        }
<span class="nc" id="L237">    }</span>

    /**
     * Gets the current font.
     * @return    this graphics context's current font.
     * @see       java.awt.Font
     * @see       java.awt.Graphics#setFont
     */
    public Font getFont() {
<span class="fc" id="L246">        return font;</span>
    }

    /**
     * Sets this graphics context's font to the specified font.
     * All subsequent text operations using this graphics context
     * use this font.
     * @param  font   the font.
     * @see     java.awt.Graphics#getFont
     */
    public void setFont(Font font) {
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (font != null) {</span>
<span class="nc" id="L258">            this.font = font;</span>
        }
<span class="nc" id="L260">    }</span>

    /**
     * Returns the bounding rectangle of the current clipping area.
     * This method refers to the user clip, which is independent of the
     * clipping associated with device bounds and window visibility.
     * If no clip has previously been set, or if the clip has been
     * cleared using &lt;code&gt;setClip(null)&lt;/code&gt;, this method returns
     * &lt;code&gt;null&lt;/code&gt;.
     * The coordinates in the rectangle are relative to the coordinate
     * system origin of this graphics context.
     * @return      the bounding rectangle of the current clipping area,
     *              or &lt;code&gt;null&lt;/code&gt; if no clip is set.
     * @see         java.awt.Graphics#getClip
     * @see         java.awt.Graphics#clipRect
     * @see         java.awt.Graphics#setClip(int, int, int, int)
     * @see         java.awt.Graphics#setClip(Shape)
     * @since       JDK1.1
     */
    public Rectangle getClipBounds() {
<span class="nc" id="L280">        Shape c = getClip();</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L282">            return null;</span>
        } else {
<span class="nc" id="L284">            return c.getBounds();</span>
        }
    }


    /**
     * Intersects the current clip with the specified rectangle.
     * The resulting clipping area is the intersection of the current
     * clipping area and the specified rectangle.  If there is no
     * current clipping area, either because the clip has never been
     * set, or the clip has been cleared using &lt;code&gt;setClip(null)&lt;/code&gt;,
     * the specified rectangle becomes the new clip.
     * This method sets the user clip, which is independent of the
     * clipping associated with device bounds and window visibility.
     * This method can only be used to make the current clip smaller.
     * To set the current clip larger, use any of the setClip methods.
     * Rendering operations have no effect outside of the clipping area.
     * @param x the x coordinate of the rectangle to intersect the clip with
     * @param y the y coordinate of the rectangle to intersect the clip with
     * @param width the width of the rectangle to intersect the clip with
     * @param height the height of the rectangle to intersect the clip with
     * @see #setClip(int, int, int, int)
     * @see #setClip(Shape)
     */
    public void clipRect(int x, int y, int width, int height) {
<span class="nc" id="L309">        clip(new Rectangle(x, y, width, height));</span>
<span class="nc" id="L310">    }</span>


    /**
     * Sets the current clip to the rectangle specified by the given
     * coordinates.  This method sets the user clip, which is
     * independent of the clipping associated with device bounds
     * and window visibility.
     * Rendering operations have no effect outside of the clipping area.
     * @param       x the &lt;i&gt;x&lt;/i&gt; coordinate of the new clip rectangle.
     * @param       y the &lt;i&gt;y&lt;/i&gt; coordinate of the new clip rectangle.
     * @param       width the width of the new clip rectangle.
     * @param       height the height of the new clip rectangle.
     * @see         java.awt.Graphics#clipRect
     * @see         java.awt.Graphics#setClip(Shape)
     * @since       JDK1.1
     */
    public void setClip(int x, int y, int width, int height) {
<span class="nc" id="L328">        setClip(new Rectangle(x, y, width, height));</span>
<span class="nc" id="L329">    }</span>


    /**
     * Gets the current clipping area.
     * This method returns the user clip, which is independent of the
     * clipping associated with device bounds and window visibility.
     * If no clip has previously been set, or if the clip has been
     * cleared using &lt;code&gt;setClip(null)&lt;/code&gt;, this method returns
     * &lt;code&gt;null&lt;/code&gt;.
     * @return      a &lt;code&gt;Shape&lt;/code&gt; object representing the
     *              current clipping area, or &lt;code&gt;null&lt;/code&gt; if
     *              no clip is set.
     * @see         java.awt.Graphics#getClipBounds()
     * @see         java.awt.Graphics#clipRect
     * @see         java.awt.Graphics#setClip(int, int, int, int)
     * @see         java.awt.Graphics#setClip(Shape)
     * @since       JDK1.1
     */
    public Shape getClip() {
        try {
<span class="fc" id="L350">            return transform.createInverse().createTransformedShape(clip);</span>
<span class="nc" id="L351">        } catch (NoninvertibleTransformException e) {</span>
<span class="nc" id="L352">            return null;</span>
        }
    }


    /**
     * Sets the current clipping area to an arbitrary clip shape.
     * Not all objects that implement the &lt;code&gt;Shape&lt;/code&gt;
     * interface can be used to set the clip.  The only
     * &lt;code&gt;Shape&lt;/code&gt; objects that are guaranteed to be
     * supported are &lt;code&gt;Shape&lt;/code&gt; objects that are
     * obtained via the &lt;code&gt;getClip&lt;/code&gt; method and via
     * &lt;code&gt;Rectangle&lt;/code&gt; objects.  This method sets the
     * user clip, which is independent of the clipping associated
     * with device bounds and window visibility.
     * @param clip the &lt;code&gt;Shape&lt;/code&gt; to use to set the clip
     * @see         java.awt.Graphics#getClip()
     * @see         java.awt.Graphics#clipRect
     * @see         java.awt.Graphics#setClip(int, int, int, int)
     * @since       JDK1.1
     */
    public void setClip(Shape clip) {
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (clip != null) {</span>
<span class="nc" id="L375">            this.clip = transform.createTransformedShape(clip);</span>
        } else {
<span class="nc" id="L377">            this.clip = null;</span>
        }
<span class="nc" id="L379">    }</span>

    /**
     * Sets the &lt;code&gt;Composite&lt;/code&gt; for the &lt;code&gt;Graphics2D&lt;/code&gt; context.
     * The &lt;code&gt;Composite&lt;/code&gt; is used in all drawing methods such as
     * &lt;code&gt;drawImage&lt;/code&gt;, &lt;code&gt;drawString&lt;/code&gt;, &lt;code&gt;draw&lt;/code&gt;,
     * and &lt;code&gt;fill&lt;/code&gt;.  It specifies how new pixels are to be combined
     * with the existing pixels on the graphics device during the rendering
     * process.
     * &lt;p&gt;If this &lt;code&gt;Graphics2D&lt;/code&gt; context is drawing to a
     * &lt;code&gt;Component&lt;/code&gt; on the display screen and the
     * &lt;code&gt;Composite&lt;/code&gt; is a custom object rather than an
     * instance of the &lt;code&gt;AlphaComposite&lt;/code&gt; class, and if
     * there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt;
     * method is called with an &lt;code&gt;AWTPermission(&quot;readDisplayPixels&quot;)&lt;/code&gt;
     * permission.
     *
     * @param comp the &lt;code&gt;Composite&lt;/code&gt; object to be used for rendering
     * @throws SecurityException
     *         if a custom &lt;code&gt;Composite&lt;/code&gt; object is being
     *         used to render to the screen and a security manager
     *         is set and its &lt;code&gt;checkPermission&lt;/code&gt; method
     *         does not allow the operation.
     * @see java.awt.Graphics#setXORMode
     * @see java.awt.Graphics#setPaintMode
     * @see java.awt.AlphaComposite
     */
    public void setComposite(Composite comp) {
<span class="fc" id="L407">        this.composite = comp;</span>
<span class="fc" id="L408">    }</span>


    /**
     * Sets the &lt;code&gt;Paint&lt;/code&gt; attribute for the
     * &lt;code&gt;Graphics2D&lt;/code&gt; context.  Calling this method
     * with a &lt;code&gt;null&lt;/code&gt; &lt;code&gt;Paint&lt;/code&gt; object does
     * not have any effect on the current &lt;code&gt;Paint&lt;/code&gt; attribute
     * of this &lt;code&gt;Graphics2D&lt;/code&gt;.
     * @param paint the &lt;code&gt;Paint&lt;/code&gt; object to be used to generate
     * color during the rendering process, or &lt;code&gt;null&lt;/code&gt;
     * @see java.awt.Graphics#setColor
     * @see java.awt.GradientPaint
     * @see java.awt.TexturePaint
     */
    public void setPaint(Paint paint) {
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">        if (paint == null) {</span>
<span class="nc" id="L425">            return;</span>
        }

<span class="fc" id="L428">        this.paint = paint;</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">        if (paint instanceof Color) {</span>
<span class="fc" id="L430">            foreground = (Color)paint;</span>
        } else {
            // use default; otherwise the previous Color will be used
<span class="fc" id="L433">            foreground = Color.black;</span>
        }
<span class="fc" id="L435">    }</span>


    /**
     * Sets the &lt;code&gt;Stroke&lt;/code&gt; for the &lt;code&gt;Graphics2D&lt;/code&gt; context.
     * @param s the &lt;code&gt;Stroke&lt;/code&gt; object to be used to stroke a
     * &lt;code&gt;Shape&lt;/code&gt; during the rendering process
     * @see BasicStroke
     */
    public void setStroke(Stroke s) {
<span class="nc" id="L445">        stroke = s;</span>
<span class="nc" id="L446">    }</span>

    /**
     * Sets the value of a single preference for the rendering algorithms.
     * Hint categories include controls for rendering quality and overall
     * time/quality trade-off in the rendering process.  Refer to the
     * &lt;code&gt;RenderingHints&lt;/code&gt; class for definitions of some common
     * keys and values.
     * @param hintKey the key of the hint to be set.
     * @param hintValue the value indicating preferences for the specified
     * hint category.
     * @see RenderingHints
     */
    public void setRenderingHint(RenderingHints.Key hintKey, Object hintValue) {
<span class="nc" id="L460">        hints.put(hintKey, hintValue);</span>
<span class="nc" id="L461">    }</span>


    /**
     * Returns the value of a single preference for the rendering algorithms.
     * Hint categories include controls for rendering quality and overall
     * time/quality trade-off in the rendering process.  Refer to the
     * &lt;code&gt;RenderingHints&lt;/code&gt; class for definitions of some common
     * keys and values.
     * @param hintKey the key corresponding to the hint to get.
     * @return an object representing the value for the specified hint key.
     * Some of the keys and their associated values are defined in the
     * &lt;code&gt;RenderingHints&lt;/code&gt; class.
     * @see RenderingHints
     */
    public Object getRenderingHint(RenderingHints.Key hintKey) {
<span class="nc" id="L477">        return hints.get(hintKey);</span>
    }


    /**
     * Replaces the values of all preferences for the rendering
     * algorithms with the specified &lt;code&gt;hints&lt;/code&gt;.
     * The existing values for all rendering hints are discarded and
     * the new set of known hints and values are initialized from the
     * specified {@link Map} object.
     * Hint categories include controls for rendering quality and
     * overall time/quality trade-off in the rendering process.
     * Refer to the &lt;code&gt;RenderingHints&lt;/code&gt; class for definitions of
     * some common keys and values.
     * @param hints the rendering hints to be set
     * @see RenderingHints
     */
    public void setRenderingHints(Map hints) {
<span class="nc" id="L495">        this.hints = new RenderingHints(hints);</span>
<span class="nc" id="L496">    }</span>


    /**
     * Sets the values of an arbitrary number of preferences for the
     * rendering algorithms.
     * Only values for the rendering hints that are present in the
     * specified &lt;code&gt;Map&lt;/code&gt; object are modified.
     * All other preferences not present in the specified
     * object are left unmodified.
     * Hint categories include controls for rendering quality and
     * overall time/quality trade-off in the rendering process.
     * Refer to the &lt;code&gt;RenderingHints&lt;/code&gt; class for definitions of
     * some common keys and values.
     * @param hints the rendering hints to be set
     * @see RenderingHints
     */
    public void addRenderingHints(Map hints) {
<span class="nc" id="L514">        this.hints.putAll(hints);</span>
<span class="nc" id="L515">    }</span>


    /**
     * Gets the preferences for the rendering algorithms.  Hint categories
     * include controls for rendering quality and overall time/quality
     * trade-off in the rendering process.
     * Returns all of the hint key/value pairs that were ever specified in
     * one operation.  Refer to the
     * &lt;code&gt;RenderingHints&lt;/code&gt; class for definitions of some common
     * keys and values.
     * @return a reference to an instance of &lt;code&gt;RenderingHints&lt;/code&gt;
     * that contains the current preferences.
     * @see RenderingHints
     */
    public RenderingHints getRenderingHints() {
<span class="nc" id="L531">        return hints;</span>
    }

    /**
     * Translates the origin of the graphics context to the point
     * (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) in the current coordinate system.
     * Modifies this graphics context so that its new origin corresponds
     * to the point (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) in this graphics context's
     * original coordinate system.  All coordinates used in subsequent
     * rendering operations on this graphics context will be relative
     * to this new origin.
     * @param  x   the &lt;i&gt;x&lt;/i&gt; coordinate.
     * @param  y   the &lt;i&gt;y&lt;/i&gt; coordinate.
     */
    public void translate(int x, int y) {
<span class="nc bnc" id="L546" title="All 4 branches missed.">        if (x != 0 || y != 0) {</span>
<span class="nc" id="L547">            transform.translate(x, y);</span>
<span class="nc" id="L548">            transformStack.add(TransformStackElement.createTranslateElement(x, y));</span>
        }
<span class="nc" id="L550">    }</span>


    /**
     * Concatenates the current
     * &lt;code&gt;Graphics2D&lt;/code&gt; &lt;code&gt;Transform&lt;/code&gt;
     * with a translation transform.
     * Subsequent rendering is translated by the specified
     * distance relative to the previous position.
     * This is equivalent to calling transform(T), where T is an
     * &lt;code&gt;AffineTransform&lt;/code&gt; represented by the following matrix:
     * &lt;pre&gt;
     *          [   1    0    tx  ]
     *          [   0    1    ty  ]
     *          [   0    0    1   ]
     * &lt;/pre&gt;
     * @param tx the distance to translate along the x-axis
     * @param ty the distance to translate along the y-axis
     */
    public void translate(double tx, double ty) {
<span class="nc" id="L570">        transform.translate(tx, ty);</span>
<span class="nc" id="L571">        transformStack.add(TransformStackElement.createTranslateElement(tx, ty));</span>
<span class="nc" id="L572">    }</span>

    /**
     * Concatenates the current &lt;code&gt;Graphics2D&lt;/code&gt;
     * &lt;code&gt;Transform&lt;/code&gt; with a rotation transform.
     * Subsequent rendering is rotated by the specified radians relative
     * to the previous origin.
     * This is equivalent to calling &lt;code&gt;transform(R)&lt;/code&gt;, where R is an
     * &lt;code&gt;AffineTransform&lt;/code&gt; represented by the following matrix:
     * &lt;pre&gt;
     *          [   cos(theta)    -sin(theta)    0   ]
     *          [   sin(theta)     cos(theta)    0   ]
     *          [       0              0         1   ]
     * &lt;/pre&gt;
     * Rotating with a positive angle theta rotates points on the positive
     * x axis toward the positive y axis.
     * @param theta the angle of rotation in radians
     */
    public void rotate(double theta) {
<span class="nc" id="L591">        transform.rotate(theta);</span>
<span class="nc" id="L592">        transformStack.add(TransformStackElement.createRotateElement(theta));</span>
<span class="nc" id="L593">    }</span>

    /**
     * Concatenates the current &lt;code&gt;Graphics2D&lt;/code&gt;
     * &lt;code&gt;Transform&lt;/code&gt; with a translated rotation
     * transform.  Subsequent rendering is transformed by a transform
     * which is constructed by translating to the specified location,
     * rotating by the specified radians, and translating back by the same
     * amount as the original translation.  This is equivalent to the
     * following sequence of calls:
     * &lt;pre&gt;
     *          translate(x, y);
     *          rotate(theta);
     *          translate(-x, -y);
     * &lt;/pre&gt;
     * Rotating with a positive angle theta rotates points on the positive
     * x axis toward the positive y axis.
     * @param theta the angle of rotation in radians
     * @param x x coordinate of the origin of the rotation
     * @param y y coordinate of the origin of the rotation
     */
    public void rotate(double theta, double x, double y) {
<span class="nc" id="L615">        transform.rotate(theta, x, y);</span>
<span class="nc" id="L616">        transformStack.add(TransformStackElement.createTranslateElement(x, y));</span>
<span class="nc" id="L617">        transformStack.add(TransformStackElement.createRotateElement(theta));</span>
<span class="nc" id="L618">        transformStack.add(TransformStackElement.createTranslateElement(-x, -y));</span>
<span class="nc" id="L619">    }</span>

    /**
     * Concatenates the current &lt;code&gt;Graphics2D&lt;/code&gt;
     * &lt;code&gt;Transform&lt;/code&gt; with a scaling transformation
     * Subsequent rendering is resized according to the specified scaling
     * factors relative to the previous scaling.
     * This is equivalent to calling &lt;code&gt;transform(S)&lt;/code&gt;, where S is an
     * &lt;code&gt;AffineTransform&lt;/code&gt; represented by the following matrix:
     * &lt;pre&gt;
     *          [   sx   0    0   ]
     *          [   0    sy   0   ]
     *          [   0    0    1   ]
     * &lt;/pre&gt;
     * @param sx the amount by which X coordinates in subsequent
     * rendering operations are multiplied relative to previous
     * rendering operations.
     * @param sy the amount by which Y coordinates in subsequent
     * rendering operations are multiplied relative to previous
     * rendering operations.
     */
    public void scale(double sx, double sy) {
<span class="nc" id="L641">        transform.scale(sx, sy);</span>
<span class="nc" id="L642">        transformStack.add(TransformStackElement.createScaleElement(sx, sy));</span>
<span class="nc" id="L643">    }</span>

    /**
     * Concatenates the current &lt;code&gt;Graphics2D&lt;/code&gt;
     * &lt;code&gt;Transform&lt;/code&gt; with a shearing transform.
     * Subsequent renderings are sheared by the specified
     * multiplier relative to the previous position.
     * This is equivalent to calling &lt;code&gt;transform(SH)&lt;/code&gt;, where SH
     * is an &lt;code&gt;AffineTransform&lt;/code&gt; represented by the following
     * matrix:
     * &lt;pre&gt;
     *          [   1   shx   0   ]
     *          [  shy   1    0   ]
     *          [   0    0    1   ]
     * &lt;/pre&gt;
     * @param shx the multiplier by which coordinates are shifted in
     * the positive X axis direction as a function of their Y coordinate
     * @param shy the multiplier by which coordinates are shifted in
     * the positive Y axis direction as a function of their X coordinate
     */
    public void shear(double shx, double shy) {
<span class="nc" id="L664">        transform.shear(shx, shy);</span>
<span class="nc" id="L665">        transformStack.add(TransformStackElement.createShearElement(shx, shy));</span>
<span class="nc" id="L666">    }</span>

    /**
     * Composes an &lt;code&gt;AffineTransform&lt;/code&gt; object with the
     * &lt;code&gt;Transform&lt;/code&gt; in this &lt;code&gt;Graphics2D&lt;/code&gt; according
     * to the rule last-specified-first-applied.  If the current
     * &lt;code&gt;Transform&lt;/code&gt; is Cx, the result of composition
     * with Tx is a new &lt;code&gt;Transform&lt;/code&gt; Cx'.  Cx' becomes the
     * current &lt;code&gt;Transform&lt;/code&gt; for this &lt;code&gt;Graphics2D&lt;/code&gt;.
     * Transforming a point p by the updated &lt;code&gt;Transform&lt;/code&gt; Cx' is
     * equivalent to first transforming p by Tx and then transforming
     * the result by the original &lt;code&gt;Transform&lt;/code&gt; Cx.  In other
     * words, Cx'(p) = Cx(Tx(p)).  A copy of the Tx is made, if necessary,
     * so further modifications to Tx do not affect rendering.
     * @param tx the &lt;code&gt;AffineTransform&lt;/code&gt; object to be composed with
     * the current &lt;code&gt;Transform&lt;/code&gt;
     * @see #setTransform
     * @see AffineTransform
     */
    public void transform(AffineTransform tx) {
<span class="nc" id="L686">        transform.concatenate(tx);</span>
<span class="nc" id="L687">        transformStack.add(TransformStackElement.createGeneralTransformElement(tx));</span>
<span class="nc" id="L688">    }</span>

    /**
     * Sets the &lt;code&gt;Transform&lt;/code&gt; in the &lt;code&gt;Graphics2D&lt;/code&gt;
     * context.
     * @param tx the &lt;code&gt;AffineTransform&lt;/code&gt; object to be used in the
     * rendering process
     * @see #transform
     * @see AffineTransform
     */
    public void setTransform(AffineTransform tx) {
<span class="fc" id="L699">        transform = new AffineTransform(tx);</span>
<span class="fc" id="L700">        invalidateTransformStack();</span>
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">        if (!tx.isIdentity()) {</span>
<span class="fc" id="L702">            transformStack.add(TransformStackElement.createGeneralTransformElement(tx));</span>
        }
<span class="fc" id="L704">    }</span>

    /**
     * Marks the GraphicContext's isNewTransformStack to false
     * as a memento that the current transform stack was read and
     * has not been reset. Only the setTransform method can
     * override this memento.
     */
    public void validateTransformStack() {
<span class="nc" id="L713">        transformStackValid = true;</span>
<span class="nc" id="L714">    }</span>

    /**
     * Checks the status of the transform stack.
     * @return true if the transform stack is valid
     */
    public boolean isTransformStackValid() {
<span class="nc" id="L721">        return transformStackValid;</span>
    }

    /**
     * @return array containing the successive transforms that
     *         were concatenated with the original one.
     */
    public TransformStackElement[] getTransformStack() {
<span class="nc" id="L729">        TransformStackElement[] stack = new TransformStackElement[transformStack.size()];</span>
<span class="nc" id="L730">        transformStack.toArray(stack);</span>
<span class="nc" id="L731">        return stack;</span>
    }

    /**
     * Marks the GraphicContext's isNewTransformStack to true
     * as a memento that the current transform stack was reset
     * since it was last read. Only validateTransformStack
     * can override this memento
     */
    protected void invalidateTransformStack() {
<span class="fc" id="L741">        transformStack.clear();</span>
<span class="fc" id="L742">        transformStackValid = false;</span>
<span class="fc" id="L743">    }</span>

    /**
     * Returns a copy of the current &lt;code&gt;Transform&lt;/code&gt; in the
     * &lt;code&gt;Graphics2D&lt;/code&gt; context.
     * @return the current &lt;code&gt;AffineTransform&lt;/code&gt; in the
     *             &lt;code&gt;Graphics2D&lt;/code&gt; context.
     * @see #transform
     * @see #setTransform
     */
    public AffineTransform getTransform() {
<span class="fc" id="L754">        return new AffineTransform(transform);</span>
    }

    /**
     * Returns the current &lt;code&gt;Paint&lt;/code&gt; of the
     * &lt;code&gt;Graphics2D&lt;/code&gt; context.
     * @return the current &lt;code&gt;Graphics2D&lt;/code&gt; &lt;code&gt;Paint&lt;/code&gt;,
     * which defines a color or pattern.
     * @see #setPaint
     * @see java.awt.Graphics#setColor
     */
    public Paint getPaint() {
<span class="fc" id="L766">        return paint;</span>
    }


    /**
     * Returns the current &lt;code&gt;Composite&lt;/code&gt; in the
     * &lt;code&gt;Graphics2D&lt;/code&gt; context.
     * @return the current &lt;code&gt;Graphics2D&lt;/code&gt; &lt;code&gt;Composite&lt;/code&gt;,
     *              which defines a compositing style.
     * @see #setComposite
     */
    public Composite getComposite() {
<span class="fc" id="L778">        return composite;</span>
    }

    /**
     * Sets the background color for the &lt;code&gt;Graphics2D&lt;/code&gt; context.
     * The background color is used for clearing a region.
     * When a &lt;code&gt;Graphics2D&lt;/code&gt; is constructed for a
     * &lt;code&gt;Component&lt;/code&gt;, the background color is
     * inherited from the &lt;code&gt;Component&lt;/code&gt;. Setting the background color
     * in the &lt;code&gt;Graphics2D&lt;/code&gt; context only affects the subsequent
     * &lt;code&gt;clearRect&lt;/code&gt; calls and not the background color of the
     * &lt;code&gt;Component&lt;/code&gt;.  To change the background
     * of the &lt;code&gt;Component&lt;/code&gt;, use appropriate methods of
     * the &lt;code&gt;Component&lt;/code&gt;.
     * @param color the background color that isused in
     * subsequent calls to &lt;code&gt;clearRect&lt;/code&gt;
     * @see #getBackground
     * @see java.awt.Graphics#clearRect
     */
    public void setBackground(Color color) {
<span class="nc bnc" id="L798" title="All 2 branches missed.">        if (color == null) {</span>
<span class="nc" id="L799">            return;</span>
        }

<span class="nc" id="L802">        background = color;</span>
<span class="nc" id="L803">    }</span>


    /**
     * Returns the background color used for clearing a region.
     * @return the current &lt;code&gt;Graphics2D&lt;/code&gt; &lt;code&gt;Color&lt;/code&gt;,
     * which defines the background color.
     * @see #setBackground
     */
    public Color getBackground() {
<span class="nc" id="L813">        return background;</span>
    }

    /**
     * Returns the current &lt;code&gt;Stroke&lt;/code&gt; in the
     * &lt;code&gt;Graphics2D&lt;/code&gt; context.
     * @return the current &lt;code&gt;Graphics2D&lt;/code&gt; &lt;code&gt;Stroke&lt;/code&gt;,
     *                 which defines the line style.
     * @see #setStroke
     */
    public Stroke getStroke() {
<span class="fc" id="L824">        return stroke;</span>
    }


    /**
     * Intersects the current &lt;code&gt;Clip&lt;/code&gt; with the interior of the
     * specified &lt;code&gt;Shape&lt;/code&gt; and sets the &lt;code&gt;Clip&lt;/code&gt; to the
     * resulting intersection.  The specified &lt;code&gt;Shape&lt;/code&gt; is
     * transformed with the current &lt;code&gt;Graphics2D&lt;/code&gt;
     * &lt;code&gt;Transform&lt;/code&gt; before being intersected with the current
     * &lt;code&gt;Clip&lt;/code&gt;.  This method is used to make the current
     * &lt;code&gt;Clip&lt;/code&gt; smaller.
     * To make the &lt;code&gt;Clip&lt;/code&gt; larger, use &lt;code&gt;setClip&lt;/code&gt;.
     * The &lt;i&gt;user clip&lt;/i&gt; modified by this method is independent of the
     * clipping associated with device bounds and visibility.  If no clip has
     * previously been set, or if the clip has been cleared using
     * {@link java.awt.Graphics#setClip(Shape) setClip} with a
     * &lt;code&gt;null&lt;/code&gt; argument, the specified &lt;code&gt;Shape&lt;/code&gt; becomes
     * the new user clip.
     * @param s the &lt;code&gt;Shape&lt;/code&gt; to be intersected with the current
     *          &lt;code&gt;Clip&lt;/code&gt;.  If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     *          this method clears the current &lt;code&gt;Clip&lt;/code&gt;.
     */
    public void clip(Shape s) {
<span class="nc bnc" id="L848" title="All 2 branches missed.">        if (s != null) {</span>
<span class="nc" id="L849">            s = transform.createTransformedShape(s);</span>
        }

<span class="nc bnc" id="L852" title="All 2 branches missed.">        if (clip != null) {</span>
<span class="nc" id="L853">            Area newClip = new Area(clip);</span>
<span class="nc" id="L854">            newClip.intersect(new Area(s));</span>
<span class="nc" id="L855">            clip = new GeneralPath(newClip);</span>
<span class="nc" id="L856">        } else {</span>
<span class="nc" id="L857">            clip = s;</span>
        }
<span class="nc" id="L859">    }</span>

    /**
     * Get the rendering context of the &lt;code&gt;Font&lt;/code&gt; within this
     * &lt;code&gt;Graphics2D&lt;/code&gt; context.
     * The {@link FontRenderContext}
     * encapsulates application hints such as anti-aliasing and
     * fractional metrics, as well as target device specific information
     * such as dots-per-inch.  This information should be provided by the
     * application when using objects that perform typographical
     * formatting, such as &lt;code&gt;Font&lt;/code&gt; and
     * &lt;code&gt;TextLayout&lt;/code&gt;.  This information should also be provided
     * by applications that perform their own layout and need accurate
     * measurements of various characteristics of glyphs such as advance
     * and line height when various rendering hints have been applied to
     * the text rendering.
     *
     * @return a reference to an instance of FontRenderContext.
     * @see java.awt.font.FontRenderContext
     * @see java.awt.Font#createGlyphVector(FontRenderContext,char[])
     * @see java.awt.font.TextLayout
     * @since     JDK1.2
     */
    public FontRenderContext getFontRenderContext() {
        //
        // Find if antialiasing should be used.
        //
<span class="fc" id="L886">        Object antialiasingHint = hints.get(RenderingHints.KEY_TEXT_ANTIALIASING);</span>
<span class="fc" id="L887">        boolean isAntialiased = true;</span>
<span class="pc bpc" id="L888" title="2 of 4 branches missed.">        if (antialiasingHint != RenderingHints.VALUE_TEXT_ANTIALIAS_ON</span>
           &amp;&amp; antialiasingHint != RenderingHints.VALUE_TEXT_ANTIALIAS_DEFAULT) {

            // If antialias was not turned off, then use the general rendering
            // hint.
<span class="pc bpc" id="L893" title="1 of 2 branches missed.">            if (antialiasingHint != RenderingHints.VALUE_TEXT_ANTIALIAS_OFF) {</span>
<span class="fc" id="L894">                antialiasingHint = hints.get(RenderingHints.KEY_ANTIALIASING);</span>

                // Test general hint
<span class="pc bpc" id="L897" title="2 of 4 branches missed.">                if (antialiasingHint != RenderingHints.VALUE_ANTIALIAS_ON</span>
                   &amp;&amp; antialiasingHint != RenderingHints.VALUE_ANTIALIAS_DEFAULT) {
                    // Antialiasing was not requested. However, if it was not turned
                    // off explicitly, use it.
<span class="pc bpc" id="L901" title="1 of 2 branches missed.">                    if (antialiasingHint == RenderingHints.VALUE_ANTIALIAS_OFF) {</span>
<span class="nc" id="L902">                        isAntialiased = false;</span>
                    }
                }
            } else {
<span class="nc" id="L906">                isAntialiased = false;</span>
            }

        }

        //
        // Find out whether fractional metrics should be used.
        //
<span class="fc" id="L914">        boolean useFractionalMetrics = true;</span>
<span class="pc bpc" id="L915" title="1 of 2 branches missed.">        if (hints.get(RenderingHints.KEY_FRACTIONALMETRICS)</span>
           == RenderingHints.VALUE_FRACTIONALMETRICS_OFF) {
<span class="nc" id="L917">            useFractionalMetrics = false;</span>
        }

<span class="fc" id="L920">        FontRenderContext frc = new FontRenderContext(defaultTransform,</span>
                                                      isAntialiased,
                                                      useFractionalMetrics);
<span class="fc" id="L923">        return frc;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>