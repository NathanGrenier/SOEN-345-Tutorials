<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultGraphics2D.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">org.apache.xmlgraphics:xmlgraphics-commons</a> &gt; <a href="index.source.html" class="el_package">org.apache.xmlgraphics.java2d</a> &gt; <span class="el_source">DefaultGraphics2D.java</span></div><h1>DefaultGraphics2D.java</h1><pre class="source lang-java linenums">/* $$ This file has been instrumented by Clover 4.5.2#20240131180750 $$ *//*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* $Id: DefaultGraphics2D.java 1732018 2016-02-24 04:51:06Z gadams $ */

package org.apache.xmlgraphics.java2d;

import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.Image;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.awt.image.ImageObserver;
import java.awt.image.RenderedImage;
import java.awt.image.renderable.RenderableImage;
import java.text.AttributedCharacterIterator;

// CSOFF: WhitespaceAround

/**
 * This concrete implementation of &lt;tt&gt;AbstractGraphics2D&lt;/tt&gt; is a
 * simple help to programmers to get started with their own
 * implementation of &lt;tt&gt;Graphics2D&lt;/tt&gt;.
 * &lt;tt&gt;DefaultGraphics2D&lt;/tt&gt; implements all the abstract methods
 * is &lt;tt&gt;AbstractGraphics2D&lt;/tt&gt; and makes it easy to start
 * implementing a &lt;tt&gt;Graphic2D&lt;/tt&gt; piece-meal.
 *
 * @version $Id: DefaultGraphics2D.java 1732018 2016-02-24 04:51:06Z gadams $
 * @see org.apache.xmlgraphics.java2d.AbstractGraphics2D
 *
 * Originally authored by Vincent Hardy.
 */
<span class="nc bnc" id="L52" title="All 4 branches missed.">public class DefaultGraphics2D extends AbstractGraphics2D {public static class __CLR4_5_2barbarm6lb50su{public static com_atlassian_clover.CoverageRecorder R;public static com_atlassian_clover.CloverProfile[] profiles = { };@java.lang.SuppressWarnings(&quot;unchecked&quot;) public static &lt;I, T extends I&gt; I lambdaInc(final int i,final T l,final int si){java.lang.reflect.InvocationHandler h=new java.lang.reflect.InvocationHandler(){public java.lang.Object invoke(java.lang.Object p,java.lang.reflect.Method m,java.lang.Object[] a) throws Throwable{R.inc(i);R.inc(si);try{return m.invoke(l,a);}catch(java.lang.reflect.InvocationTargetException e){throw e.getCause()!=null?e.getCause():new RuntimeException(&quot;Clover failed to invoke instrumented lambda&quot;,e);}}};return (I)java.lang.reflect.Proxy.newProxyInstance(l.getClass().getClassLoader(),l.getClass().getInterfaces(),h);}public static &lt;T&gt; T caseInc(int i,java.util.function.Supplier&lt;T&gt; s){R.inc(i);return s.get();}public static void caseInc(int i,Runnable r){R.inc(i);r.run();}static{com_atlassian_clover.CoverageRecorder _R=null;try{com_atlassian_clover.CloverVersionInfo.An_old_version_of_clover_is_on_your_compilation_classpath___Please_remove___Required_version_is___4_5_2();if(20240131180750L!=com_atlassian_clover.CloverVersionInfo.getBuildStamp()){com_atlassian_clover.Clover.l(&quot;[CLOVER] WARNING: The Clover version used in instrumentation shall match the runtime version.&quot;);com_atlassian_clover.Clover.l(&quot;[CLOVER] WARNING: Instr=4.5.2#20240131180750,Runtime=&quot;+com_atlassian_clover.CloverVersionInfo.getReleaseNum()+&quot;#&quot;+com_atlassian_clover.CloverVersionInfo.getBuildStamp());}R=com_atlassian_clover.Clover.getNullRecorder();_R=com_atlassian_clover.Clover.getNullRecorder();_R=com_atlassian_clover.Clover.getRecorder(&quot;\u002f\u0063\u006f\u0064\u0065\u002f\u0063\u006f\u006e\u0063\u006f\u0072\u0064\u0069\u0061\u002f\u0053\u004f\u0045\u004e\u002d\u0033\u0034\u0035\u002d\u0054\u0075\u0074\u006f\u0072\u0069\u0061\u006c\u0073\u002f\u0074\u0075\u0074\u006f\u0072\u0069\u0061\u006c\u0031\u002f\u0050\u0061\u0072\u0074\u002d\u0042\u002f\u0078\u006d\u006c\u0067\u0072\u0061\u0070\u0068\u0069\u0063\u0073\u002d\u0063\u006f\u006d\u006d\u006f\u006e\u0073\u002d\u0032\u002e\u0038\u002f\u0074\u0061\u0072\u0067\u0065\u0074\u002f\u0063\u006c\u006f\u0076\u0065\u0072\u002f\u0063\u006c\u006f\u0076\u0065\u0072\u002e\u0064\u0062&quot;,1738360798893L,8589935092L,14681,profiles,new java.lang.String[]{&quot;clover.distributed.coverage&quot;,null});}catch(java.lang.SecurityException e){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised because it has insufficient security privileges. Please consult the Clover documentation on the security policy file changes required. (&quot;+e.getClass()+&quot;:&quot;+e.getMessage()+&quot;)&quot;);}catch(java.lang.NoClassDefFoundError e){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised. Are you sure you have Clover in the runtime classpath? (&quot;+e.getClass()+&quot;:&quot;+e.getMessage()+&quot;)&quot;);}catch(java.lang.Throwable t){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised because of an unexpected error. (&quot;+t.getClass()+&quot;:&quot;+t.getMessage()+&quot;)&quot;);}R=_R;}}public static final com_atlassian_clover.TestNameSniffer __CLR4_5_2_TEST_NAME_SNIFFER=com_atlassian_clover.TestNameSniffer.NULL_INSTANCE;</span>
    /**
     * Default constructor
     */
    public DefaultGraphics2D(boolean textAsShapes) {
<span class="nc" id="L57">        super(textAsShapes);__CLR4_5_2barbarm6lb50su.R.inc(14644);try{__CLR4_5_2barbarm6lb50su.R.inc(14643);</span>
<span class="nc" id="L58">    }finally{__CLR4_5_2barbarm6lb50su.R.flushNeeded();}}</span>

    /**
     * This constructor supports the create method
     */
    public DefaultGraphics2D(DefaultGraphics2D g) {
<span class="nc" id="L64">        super(g);__CLR4_5_2barbarm6lb50su.R.inc(14646);try{__CLR4_5_2barbarm6lb50su.R.inc(14645);</span>
<span class="nc" id="L65">    }finally{__CLR4_5_2barbarm6lb50su.R.flushNeeded();}}</span>

    /**
     * Creates a new &lt;code&gt;Graphics&lt;/code&gt; object that is
     * a copy of this &lt;code&gt;Graphics&lt;/code&gt; object.
     * @return     a new graphics context that is a copy of
     *             this graphics context.
     */
<span class="nc" id="L73">    public Graphics create() {try{__CLR4_5_2barbarm6lb50su.R.inc(14647);</span>
<span class="nc" id="L74">        __CLR4_5_2barbarm6lb50su.R.inc(14648);return new DefaultGraphics2D(this);</span>
<span class="nc" id="L75">    }finally{__CLR4_5_2barbarm6lb50su.R.flushNeeded();}}</span>

    /**
     * Draws as much of the specified image as is currently available.
     * The image is drawn with its top-left corner at
     * (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) in this graphics context's coordinate
     * space. Transparent pixels in the image do not affect whatever
     * pixels are already there.
     * &lt;p&gt;
     * This method returns immediately in all cases, even if the
     * complete image has not yet been loaded, and it has not been dithered
     * and converted for the current output device.
     * &lt;p&gt;
     * If the image has not yet been completely loaded, then
     * &lt;code&gt;drawImage&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. As more of
     * the image becomes available, the process that draws the image notifies
     * the specified image observer.
     * @param    img the specified image to be drawn.
     * @param    x   the &lt;i&gt;x&lt;/i&gt; coordinate.
     * @param    y   the &lt;i&gt;y&lt;/i&gt; coordinate.
     * @param    observer    object to be notified as more of
     *                          the image is converted.
     * @see      java.awt.Image
     * @see      java.awt.image.ImageObserver
     * @see      java.awt.image.ImageObserver#imageUpdate(java.awt.Image, int, int, int, int, int)
     */
<span class="nc" id="L101">    public boolean drawImage(Image img, int x, int y, ImageObserver observer) {try{__CLR4_5_2barbarm6lb50su.R.inc(14649);</span>
<span class="nc" id="L102">        __CLR4_5_2barbarm6lb50su.R.inc(14650);System.err.println(&quot;drawImage&quot;);</span>
<span class="nc" id="L103">        __CLR4_5_2barbarm6lb50su.R.inc(14651);return true;</span>
<span class="nc" id="L104">    }finally{__CLR4_5_2barbarm6lb50su.R.flushNeeded();}}</span>

    /**
     * Draws as much of the specified image as has already been scaled
     * to fit inside the specified rectangle.
     * &lt;p&gt;
     * The image is drawn inside the specified rectangle of this
     * graphics context's coordinate space, and is scaled if
     * necessary. Transparent pixels do not affect whatever pixels
     * are already there.
     * &lt;p&gt;
     * This method returns immediately in all cases, even if the
     * entire image has not yet been scaled, dithered, and converted
     * for the current output device.
     * If the current output representation is not yet complete, then
     * &lt;code&gt;drawImage&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. As more of
     * the image becomes available, the process that draws the image notifies
     * the image observer by calling its &lt;code&gt;imageUpdate&lt;/code&gt; method.
     * &lt;p&gt;
     * A scaled version of an image will not necessarily be
     * available immediately just because an unscaled version of the
     * image has been constructed for this output device.  Each size of
     * the image may be cached separately and generated from the original
     * data in a separate image production sequence.
     * @param    img    the specified image to be drawn.
     * @param    x      the &lt;i&gt;x&lt;/i&gt; coordinate.
     * @param    y      the &lt;i&gt;y&lt;/i&gt; coordinate.
     * @param    width  the width of the rectangle.
     * @param    height the height of the rectangle.
     * @param    observer    object to be notified as more of
     *                          the image is converted.
     * @see      java.awt.Image
     * @see      java.awt.image.ImageObserver
     * @see      java.awt.image.ImageObserver#imageUpdate(java.awt.Image, int, int, int, int, int)
     */
    public boolean drawImage(Image img, int x, int y,
                             int width, int height,
<span class="nc" id="L141">                             ImageObserver observer) {try{__CLR4_5_2barbarm6lb50su.R.inc(14652);</span>
<span class="nc" id="L142">        __CLR4_5_2barbarm6lb50su.R.inc(14653);System.out.println(&quot;drawImage&quot;);</span>
<span class="nc" id="L143">        __CLR4_5_2barbarm6lb50su.R.inc(14654);return true;</span>
<span class="nc" id="L144">    }finally{__CLR4_5_2barbarm6lb50su.R.flushNeeded();}}</span>

    /**
     * Disposes of this graphics context and releases
     * any system resources that it is using.
     * A &lt;code&gt;Graphics&lt;/code&gt; object cannot be used after
     * &lt;code&gt;dispose&lt;/code&gt;has been called.
     * &lt;p&gt;
     * When a Java program runs, a large number of &lt;code&gt;Graphics&lt;/code&gt;
     * objects can be created within a short time frame.
     * Although the finalization process of the garbage collector
     * also disposes of the same system resources, it is preferable
     * to manually free the associated resources by calling this
     * method rather than to rely on a finalization process which
     * may not run to completion for a long period of time.
     * &lt;p&gt;
     * Graphics objects which are provided as arguments to the
     * &lt;code&gt;paint&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; methods
     * of components are automatically released by the system when
     * those methods return. For efficiency, programmers should
     * call &lt;code&gt;dispose&lt;/code&gt; when finished using
     * a &lt;code&gt;Graphics&lt;/code&gt; object only if it was created
     * directly from a component or another &lt;code&gt;Graphics&lt;/code&gt; object.
     * @see         java.awt.Graphics#finalize
     * @see         java.awt.Component#paint
     * @see         java.awt.Component#update
     * @see         java.awt.Component#getGraphics
     * @see         java.awt.Graphics#create()
     */
<span class="nc" id="L173">    public void dispose() {try{__CLR4_5_2barbarm6lb50su.R.inc(14655);</span>
<span class="nc" id="L174">        __CLR4_5_2barbarm6lb50su.R.inc(14656);System.out.println(&quot;dispose&quot;);</span>
<span class="nc" id="L175">    }finally{__CLR4_5_2barbarm6lb50su.R.flushNeeded();}}</span>

    /**
     * Strokes the outline of a &lt;code&gt;Shape&lt;/code&gt; using the settings of the
     * current &lt;code&gt;Graphics2D&lt;/code&gt; context.  The rendering attributes
     * applied include the &lt;code&gt;Clip&lt;/code&gt;, &lt;code&gt;Transform&lt;/code&gt;,
     * &lt;code&gt;Paint&lt;/code&gt;, &lt;code&gt;Composite&lt;/code&gt; and
     * &lt;code&gt;Stroke&lt;/code&gt; attributes.
     * @param s the &lt;code&gt;Shape&lt;/code&gt; to be rendered
     * @see #setStroke(java.awt.Stroke)
     * @see #setPaint(java.awt.Paint)
     * @see java.awt.Graphics#setColor
     * @see #setTransform(AffineTransform)
     * @see #setClip(Shape)
     * @see #setComposite(java.awt.Composite)
     */
<span class="nc" id="L191">    public void draw(Shape s) {try{__CLR4_5_2barbarm6lb50su.R.inc(14657);</span>
<span class="nc" id="L192">        __CLR4_5_2barbarm6lb50su.R.inc(14658);System.out.println(&quot;draw(Shape)&quot;);</span>
<span class="nc" id="L193">    }finally{__CLR4_5_2barbarm6lb50su.R.flushNeeded();}}</span>

    /**
     * Renders a {@link RenderedImage},
     * applying a transform from image
     * space into user space before drawing.
     * The transformation from user space into device space is done with
     * the current &lt;code&gt;Transform&lt;/code&gt; in the &lt;code&gt;Graphics2D&lt;/code&gt;.
     * The specified transformation is applied to the image before the
     * transform attribute in the &lt;code&gt;Graphics2D&lt;/code&gt; context is applied.
     * The rendering attributes applied include the &lt;code&gt;Clip&lt;/code&gt;,
     * &lt;code&gt;Transform&lt;/code&gt;, and &lt;code&gt;Composite&lt;/code&gt; attributes. Note
     * that no rendering is done if the specified transform is
     * noninvertible.
     * @param img the image to be rendered
     * @param xform the transformation from image space into user space
     * @see #setTransform(AffineTransform)
     * @see #setComposite(java.awt.Composite)
     * @see #setClip(Shape)
     */
    public void drawRenderedImage(RenderedImage img,
<span class="nc" id="L214">                                  AffineTransform xform) {try{__CLR4_5_2barbarm6lb50su.R.inc(14659);</span>
<span class="nc" id="L215">        __CLR4_5_2barbarm6lb50su.R.inc(14660);System.out.println(&quot;drawRenderedImage&quot;);</span>
<span class="nc" id="L216">    }finally{__CLR4_5_2barbarm6lb50su.R.flushNeeded();}}</span>


    /**
     * Renders a
     * {@link RenderableImage},
     * applying a transform from image space into user space before drawing.
     * The transformation from user space into device space is done with
     * the current &lt;code&gt;Transform&lt;/code&gt; in the &lt;code&gt;Graphics2D&lt;/code&gt;.
     * The specified transformation is applied to the image before the
     * transform attribute in the &lt;code&gt;Graphics2D&lt;/code&gt; context is applied.
     * The rendering attributes applied include the &lt;code&gt;Clip&lt;/code&gt;,
     * &lt;code&gt;Transform&lt;/code&gt;, and &lt;code&gt;Composite&lt;/code&gt; attributes. Note
     * that no rendering is done if the specified transform is
     * noninvertible.
     *&lt;p&gt;
     * Rendering hints set on the &lt;code&gt;Graphics2D&lt;/code&gt; object might
     * be used in rendering the &lt;code&gt;RenderableImage&lt;/code&gt;.
     * If explicit control is required over specific hints recognized by a
     * specific &lt;code&gt;RenderableImage&lt;/code&gt;, or if knowledge of which hints
     * are used is required, then a &lt;code&gt;RenderedImage&lt;/code&gt; should be
     * obtained directly from the &lt;code&gt;RenderableImage&lt;/code&gt;
     * and rendered using
     *{@link #drawRenderedImage(RenderedImage, AffineTransform) drawRenderedImage}.
     * @param img the image to be rendered
     * @param xform the transformation from image space into user space
     * @see #setTransform(AffineTransform)
     * @see #setComposite(java.awt.Composite)
     * @see #setClip(Shape)
     * @see #drawRenderedImage
     */
     public void drawRenderableImage(RenderableImage img,
<span class="nc" id="L248">                                     AffineTransform xform) {try{__CLR4_5_2barbarm6lb50su.R.inc(14661);</span>
<span class="nc" id="L249">         __CLR4_5_2barbarm6lb50su.R.inc(14662);System.out.println(&quot;drawRenderableImage&quot;);</span>
<span class="nc" id="L250">     }finally{__CLR4_5_2barbarm6lb50su.R.flushNeeded();}}</span>

    /**
     * Renders the text specified by the specified &lt;code&gt;String&lt;/code&gt;,
     * using the current &lt;code&gt;Font&lt;/code&gt; and &lt;code&gt;Paint&lt;/code&gt; attributes
     * in the &lt;code&gt;Graphics2D&lt;/code&gt; context.
     * The baseline of the first character is at position
     * (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) in the User Space.
     * The rendering attributes applied include the &lt;code&gt;Clip&lt;/code&gt;,
     * &lt;code&gt;Transform&lt;/code&gt;, &lt;code&gt;Paint&lt;/code&gt;, &lt;code&gt;Font&lt;/code&gt; and
     * &lt;code&gt;Composite&lt;/code&gt; attributes. For characters in script systems
     * such as Hebrew and Arabic, the glyphs can be rendered from right to
     * left, in which case the coordinate supplied is the location of the
     * leftmost character on the baseline.
     * @param s the &lt;code&gt;String&lt;/code&gt; to be rendered
     * @param x the x coordinate where the &lt;code&gt;String&lt;/code&gt; should be
     *          rendered
     * @param y the y coordinate where the &lt;code&gt;String&lt;/code&gt; should be
     *          rendered
     * @see #setPaint(java.awt.Paint)
     * @see java.awt.Graphics#setColor
     * @see java.awt.Graphics#setFont
     * @see #setTransform(AffineTransform)
     * @see #setComposite(java.awt.Composite)
     * @see #setClip(Shape)
     */
<span class="nc" id="L276">    public void drawString(String s, float x, float y) {try{__CLR4_5_2barbarm6lb50su.R.inc(14663);</span>
<span class="nc" id="L277">        __CLR4_5_2barbarm6lb50su.R.inc(14664);System.out.println(&quot;drawString(String)&quot;);</span>
<span class="nc" id="L278">    }finally{__CLR4_5_2barbarm6lb50su.R.flushNeeded();}}</span>

    /**
     * Renders the text of the specified iterator, using the
     * &lt;code&gt;Graphics2D&lt;/code&gt; context's current &lt;code&gt;Paint&lt;/code&gt;. The
     * iterator must specify a font
     * for each character. The baseline of the
     * first character is at position (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) in the
     * User Space.
     * The rendering attributes applied include the &lt;code&gt;Clip&lt;/code&gt;,
     * &lt;code&gt;Transform&lt;/code&gt;, &lt;code&gt;Paint&lt;/code&gt;, and
     * &lt;code&gt;Composite&lt;/code&gt; attributes.
     * For characters in script systems such as Hebrew and Arabic,
     * the glyphs can be rendered from right to left, in which case the
     * coordinate supplied is the location of the leftmost character
     * on the baseline.
     * @param iterator the iterator whose text is to be rendered
     * @param x the x coordinate where the iterator's text is to be rendered
     * @param y the y coordinate where the iterator's text is to be rendered
     * @see #setPaint(java.awt.Paint)
     * @see java.awt.Graphics#setColor
     * @see #setTransform(AffineTransform)
     * @see #setComposite(java.awt.Composite)
     * @see #setClip(Shape)
     */
     public void drawString(AttributedCharacterIterator iterator,
<span class="nc" id="L304">                            float x, float y) {try{__CLR4_5_2barbarm6lb50su.R.inc(14665);</span>
<span class="nc" id="L305">         __CLR4_5_2barbarm6lb50su.R.inc(14666);System.err.println(&quot;drawString(AttributedCharacterIterator)&quot;);</span>
<span class="nc" id="L306">     }finally{__CLR4_5_2barbarm6lb50su.R.flushNeeded();}}</span>



    /**
     * Fills the interior of a &lt;code&gt;Shape&lt;/code&gt; using the settings of the
     * &lt;code&gt;Graphics2D&lt;/code&gt; context. The rendering attributes applied
     * include the &lt;code&gt;Clip&lt;/code&gt;, &lt;code&gt;Transform&lt;/code&gt;,
     * &lt;code&gt;Paint&lt;/code&gt;, and &lt;code&gt;Composite&lt;/code&gt;.
     * @param s the &lt;code&gt;Shape&lt;/code&gt; to be filled
     * @see #setPaint(java.awt.Paint)
     * @see java.awt.Graphics#setColor
     * @see #setTransform(AffineTransform)
     * @see #setComposite(java.awt.Composite)
     * @see #setClip(Shape)
     */
<span class="nc" id="L322">    public void fill(Shape s) {try{__CLR4_5_2barbarm6lb50su.R.inc(14667);</span>
<span class="nc" id="L323">        __CLR4_5_2barbarm6lb50su.R.inc(14668);System.err.println(&quot;fill&quot;);</span>
<span class="nc" id="L324">    }finally{__CLR4_5_2barbarm6lb50su.R.flushNeeded();}}</span>

    /**
     * Returns the device configuration associated with this
     * &lt;code&gt;Graphics2D&lt;/code&gt;.
     */
<span class="nc" id="L330">    public GraphicsConfiguration getDeviceConfiguration() {try{__CLR4_5_2barbarm6lb50su.R.inc(14669);</span>
<span class="nc" id="L331">        __CLR4_5_2barbarm6lb50su.R.inc(14670);System.out.println(&quot;getDeviceConviguration&quot;);</span>
<span class="nc" id="L332">        __CLR4_5_2barbarm6lb50su.R.inc(14671);return null;</span>
<span class="nc" id="L333">    }finally{__CLR4_5_2barbarm6lb50su.R.flushNeeded();}}</span>

    /**
     * Used to create proper font metrics
     */
    private Graphics2D fmg;

<span class="nc" id="L340">    {try{__CLR4_5_2barbarm6lb50su.R.inc(14672);</span>
<span class="nc" id="L341">        __CLR4_5_2barbarm6lb50su.R.inc(14673);BufferedImage bi</span>
            = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);

<span class="nc" id="L344">        __CLR4_5_2barbarm6lb50su.R.inc(14674);fmg = bi.createGraphics();</span>
<span class="nc" id="L345">    }finally{__CLR4_5_2barbarm6lb50su.R.flushNeeded();}}</span>

    /**
     * Gets the font metrics for the specified font.
     * @return    the font metrics for the specified font.
     * @param     f the specified font
     * @see       java.awt.Graphics#getFont
     * @see       java.awt.FontMetrics
     * @see       java.awt.Graphics#getFontMetrics()
     */
<span class="nc" id="L355">    public FontMetrics getFontMetrics(Font f) {try{__CLR4_5_2barbarm6lb50su.R.inc(14675);</span>
<span class="nc" id="L356">        __CLR4_5_2barbarm6lb50su.R.inc(14676);return fmg.getFontMetrics(f);</span>
<span class="nc" id="L357">    }finally{__CLR4_5_2barbarm6lb50su.R.flushNeeded();}}</span>

    /**
     * Sets the paint mode of this graphics context to alternate between
     * this graphics context's current color and the new specified color.
     * This specifies that logical pixel operations are performed in the
     * XOR mode, which alternates pixels between the current color and
     * a specified XOR color.
     * &lt;p&gt;
     * When drawing operations are performed, pixels which are the
     * current color are changed to the specified color, and vice versa.
     * &lt;p&gt;
     * Pixels that are of colors other than those two colors are changed
     * in an unpredictable but reversible manner; if the same figure is
     * drawn twice, then all pixels are restored to their original values.
     * @param     c1 the XOR alternation color
     */
<span class="nc" id="L374">    public void setXORMode(Color c1) {try{__CLR4_5_2barbarm6lb50su.R.inc(14677);</span>
<span class="nc" id="L375">        __CLR4_5_2barbarm6lb50su.R.inc(14678);System.out.println(&quot;setXORMode&quot;);</span>
<span class="nc" id="L376">    }finally{__CLR4_5_2barbarm6lb50su.R.flushNeeded();}}</span>


    /**
     * Copies an area of the component by a distance specified by
     * &lt;code&gt;dx&lt;/code&gt; and &lt;code&gt;dy&lt;/code&gt;. From the point specified
     * by &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, this method
     * copies downwards and to the right.  To copy an area of the
     * component to the left or upwards, specify a negative value for
     * &lt;code&gt;dx&lt;/code&gt; or &lt;code&gt;dy&lt;/code&gt;.
     * If a portion of the source rectangle lies outside the bounds
     * of the component, or is obscured by another window or component,
     * &lt;code&gt;copyArea&lt;/code&gt; will be unable to copy the associated
     * pixels. The area that is omitted can be refreshed by calling
     * the component's &lt;code&gt;paint&lt;/code&gt; method.
     * @param       x the &lt;i&gt;x&lt;/i&gt; coordinate of the source rectangle.
     * @param       y the &lt;i&gt;y&lt;/i&gt; coordinate of the source rectangle.
     * @param       width the width of the source rectangle.
     * @param       height the height of the source rectangle.
     * @param       dx the horizontal distance to copy the pixels.
     * @param       dy the vertical distance to copy the pixels.
     */
    public void copyArea(int x, int y, int width, int height,
<span class="nc" id="L399">                         int dx, int dy) {try{__CLR4_5_2barbarm6lb50su.R.inc(14679);</span>
<span class="nc" id="L400">        __CLR4_5_2barbarm6lb50su.R.inc(14680);System.out.println(&quot;copyArea&quot;);</span>
<span class="nc" id="L401">    }finally{__CLR4_5_2barbarm6lb50su.R.flushNeeded();}}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>