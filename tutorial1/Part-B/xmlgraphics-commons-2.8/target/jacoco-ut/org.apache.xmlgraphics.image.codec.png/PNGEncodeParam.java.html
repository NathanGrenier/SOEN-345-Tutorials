<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PNGEncodeParam.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">org.apache.xmlgraphics:xmlgraphics-commons</a> &gt; <a href="index.source.html" class="el_package">org.apache.xmlgraphics.image.codec.png</a> &gt; <span class="el_source">PNGEncodeParam.java</span></div><h1>PNGEncodeParam.java</h1><pre class="source lang-java linenums">/* $$ This file has been instrumented by Clover 4.5.2#20240131180750 $$ *//*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* $Id: PNGEncodeParam.java 1902007 2022-06-17 09:51:56Z ssteiner $ */

package org.apache.xmlgraphics.image.codec.png;

import java.awt.image.ColorModel;
import java.awt.image.IndexColorModel;
import java.awt.image.RenderedImage;
import java.awt.image.SampleModel;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.apache.xmlgraphics.image.codec.util.ImageEncodeParam;
import org.apache.xmlgraphics.image.codec.util.PropertyUtil;

// CSOFF: MemberName
// CSOFF: MultipleVariableDeclarations
// CSOFF: NeedBraces
// CSOFF: OperatorWrap
// CSOFF: ParameterName
// CSOFF: WhitespaceAround

/**
 * An instance of &lt;code&gt;ImageEncodeParam&lt;/code&gt; for encoding images in
 * the PNG format.
 *
 * &lt;p&gt;&lt;b&gt; This class is not a committed part of the JAI API.  It may
 * be removed or changed in future releases of JAI.&lt;/b&gt;
 */
<span class="pc bpc" id="L47" title="3 of 4 branches missed.">public abstract class PNGEncodeParam implements ImageEncodeParam {public static class __CLR4_5_2u5u5m68iyfte{public static com_atlassian_clover.CoverageRecorder R;public static com_atlassian_clover.CloverProfile[] profiles = { };@java.lang.SuppressWarnings(&quot;unchecked&quot;) public static &lt;I, T extends I&gt; I lambdaInc(final int i,final T l,final int si){java.lang.reflect.InvocationHandler h=new java.lang.reflect.InvocationHandler(){public java.lang.Object invoke(java.lang.Object p,java.lang.reflect.Method m,java.lang.Object[] a) throws Throwable{R.inc(i);R.inc(si);try{return m.invoke(l,a);}catch(java.lang.reflect.InvocationTargetException e){throw e.getCause()!=null?e.getCause():new RuntimeException(&quot;Clover failed to invoke instrumented lambda&quot;,e);}}};return (I)java.lang.reflect.Proxy.newProxyInstance(l.getClass().getClassLoader(),l.getClass().getInterfaces(),h);}public static &lt;T&gt; T caseInc(int i,java.util.function.Supplier&lt;T&gt; s){R.inc(i);return s.get();}public static void caseInc(int i,Runnable r){R.inc(i);r.run();}static{com_atlassian_clover.CoverageRecorder _R=null;try{com_atlassian_clover.CloverVersionInfo.An_old_version_of_clover_is_on_your_compilation_classpath___Please_remove___Required_version_is___4_5_2();if(20240131180750L!=com_atlassian_clover.CloverVersionInfo.getBuildStamp()){com_atlassian_clover.Clover.l(&quot;[CLOVER] WARNING: The Clover version used in instrumentation shall match the runtime version.&quot;);com_atlassian_clover.Clover.l(&quot;[CLOVER] WARNING: Instr=4.5.2#20240131180750,Runtime=&quot;+com_atlassian_clover.CloverVersionInfo.getReleaseNum()+&quot;#&quot;+com_atlassian_clover.CloverVersionInfo.getBuildStamp());}R=com_atlassian_clover.Clover.getNullRecorder();_R=com_atlassian_clover.Clover.getNullRecorder();_R=com_atlassian_clover.Clover.getRecorder(&quot;\u002f\u0063\u006f\u0064\u0065\u002f\u0063\u006f\u006e\u0063\u006f\u0072\u0064\u0069\u0061\u002f\u0053\u004f\u0045\u004e\u002d\u0033\u0034\u0035\u002d\u0054\u0075\u0074\u006f\u0072\u0069\u0061\u006c\u0073\u002f\u0074\u0075\u0074\u006f\u0072\u0069\u0061\u006c\u0031\u002f\u0050\u0061\u0072\u0074\u002d\u0042\u002f\u0078\u006d\u006c\u0067\u0072\u0061\u0070\u0068\u0069\u0063\u0073\u002d\u0063\u006f\u006d\u006d\u006f\u006e\u0073\u002d\u0032\u002e\u0038\u002f\u0074\u0061\u0072\u0067\u0065\u0074\u002f\u0063\u006c\u006f\u0076\u0065\u0072\u002f\u0063\u006c\u006f\u0076\u0065\u0072\u002e\u0064\u0062&quot;,1737587872955L,8589935092L,1591,profiles,new java.lang.String[]{&quot;clover.distributed.coverage&quot;,null});}catch(java.lang.SecurityException e){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised because it has insufficient security privileges. Please consult the Clover documentation on the security policy file changes required. (&quot;+e.getClass()+&quot;:&quot;+e.getMessage()+&quot;)&quot;);}catch(java.lang.NoClassDefFoundError e){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised. Are you sure you have Clover in the runtime classpath? (&quot;+e.getClass()+&quot;:&quot;+e.getMessage()+&quot;)&quot;);}catch(java.lang.Throwable t){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised because of an unexpected error. (&quot;+t.getClass()+&quot;:&quot;+t.getMessage()+&quot;)&quot;);}R=_R;}}public static final com_atlassian_clover.TestNameSniffer __CLR4_5_2_TEST_NAME_SNIFFER=com_atlassian_clover.TestNameSniffer.NULL_INSTANCE;</span>
    private static final long serialVersionUID = -7851509538552141263L;

    /** Constant for use with the sRGB chunk. */
    public static final int INTENT_PERCEPTUAL = 0;

    /** Constant for use with the sRGB chunk. */
    public static final int INTENT_RELATIVE = 1;

    /** Constant for use with the sRGB chunk. */
    public static final int INTENT_SATURATION = 2;

    /** Constant for use with the sRGB chunk. */
    public static final int INTENT_ABSOLUTE = 3;

    /** Constant for use in filtering. */
    public static final int PNG_FILTER_NONE = 0;

    /** Constant for use in filtering. */
    public static final int PNG_FILTER_SUB = 1;

    /** Constant for use in filtering. */
    public static final int PNG_FILTER_UP = 2;

    /** Constant for use in filtering. */
    public static final int PNG_FILTER_AVERAGE = 3;

    /** Constant for use in filtering. */
    public static final int PNG_FILTER_PAETH = 4;


    /**
     * Returns an instance of &lt;code&gt;PNGEncodeParam.Palette&lt;/code&gt;,
     * &lt;code&gt;PNGEncodeParam.Gray&lt;/code&gt;, or
     * &lt;code&gt;PNGEncodeParam.RGB&lt;/code&gt; appropriate for encoding
     * the given image.
     *
     * &lt;p&gt; If the image has an &lt;code&gt;IndexColorModel&lt;/code&gt;, an
     * instance of &lt;code&gt;PNGEncodeParam.Palette&lt;/code&gt; is returned.
     * Otherwise, if the image has 1 or 2 bands an instance of
     * &lt;code&gt;PNGEncodeParam.Gray&lt;/code&gt; is returned.  In all other
     * cases an instance of &lt;code&gt;PNGEncodeParam.RGB&lt;/code&gt; is
     * returned.
     *
     * &lt;p&gt; Note that this method does not provide any guarantee that
     * the given image will be successfully encoded by the PNG
     * encoder, as it only performs a very superficial analysis of
     * the image structure.
     */
<span class="fc" id="L96">    public static PNGEncodeParam getDefaultEncodeParam(RenderedImage im) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1085);</span>
<span class="fc" id="L97">        __CLR4_5_2u5u5m68iyfte.R.inc(1086);ColorModel colorModel = im.getColorModel();</span>
<span class="pc bpc" id="L98" title="7 of 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1087);if ((((colorModel instanceof IndexColorModel)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1088)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1089)==0&amp;false))) {{</span>
<span class="nc" id="L99">            __CLR4_5_2u5u5m68iyfte.R.inc(1090);return new PNGEncodeParam.Palette();</span>
        }

<span class="fc" id="L102">        }__CLR4_5_2u5u5m68iyfte.R.inc(1091);SampleModel sampleModel = im.getSampleModel();</span>
<span class="fc" id="L103">        __CLR4_5_2u5u5m68iyfte.R.inc(1092);int numBands = sampleModel.getNumBands();</span>

<span class="pc bpc" id="L105" title="8 of 12 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1093);if ((((numBands == 1 || numBands == 2)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1094)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1095)==0&amp;false))) {{</span>
<span class="nc" id="L106">            __CLR4_5_2u5u5m68iyfte.R.inc(1096);return new PNGEncodeParam.Gray();</span>
        } }else {{
<span class="fc" id="L108">            __CLR4_5_2u5u5m68iyfte.R.inc(1097);return new PNGEncodeParam.RGB();</span>
        }
<span class="fc" id="L110">    }}finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    public static class Palette extends PNGEncodeParam {

        private static final long serialVersionUID = -5181545170427733891L;

        /** Constructs an instance of &lt;code&gt;PNGEncodeParam.Palette&lt;/code&gt;. */
<span class="nc" id="L117">        public Palette() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1098); }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        // bKGD chunk

        private boolean backgroundSet;

        /**
         * Suppresses the 'bKGD' chunk from being output.
         */
<span class="nc" id="L126">        public void unsetBackground() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1099);</span>
<span class="nc" id="L127">            __CLR4_5_2u5u5m68iyfte.R.inc(1100);backgroundSet = false;</span>
<span class="nc" id="L128">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Returns true if a 'bKGD' chunk will be output.
         */
<span class="nc" id="L133">        public boolean isBackgroundSet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1101);</span>
<span class="nc" id="L134">            __CLR4_5_2u5u5m68iyfte.R.inc(1102);return backgroundSet;</span>
<span class="nc" id="L135">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Sets the desired bit depth for a palette image.  The bit
         * depth must be one of 1, 2, 4, or 8, or else an
         * &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.
         */
<span class="nc" id="L142">        public void setBitDepth(int bitDepth) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1103);</span>
<span class="nc bnc" id="L143" title="All 8 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1104);if ((((bitDepth != 1 &amp;&amp; bitDepth != 2 &amp;&amp; bitDepth != 4</span>
<span class="nc bnc" id="L144" title="All 8 branches missed.">                &amp;&amp; bitDepth != 8)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1105)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1106)==0&amp;false))) {{</span>
<span class="nc" id="L145">                __CLR4_5_2u5u5m68iyfte.R.inc(1107);throw new IllegalArgumentException(PropertyUtil.getString(&quot;PNGEncodeParam2&quot;));</span>
            }
<span class="nc" id="L147">            }__CLR4_5_2u5u5m68iyfte.R.inc(1108);this.bitDepth = bitDepth;</span>
<span class="nc" id="L148">            __CLR4_5_2u5u5m68iyfte.R.inc(1109);bitDepthSet = true;</span>
<span class="nc" id="L149">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        // PLTE chunk

        private int[] palette;
        private boolean paletteSet;

        /**
         * Sets the RGB palette of the image to be encoded.
         * The &lt;code&gt;rgb&lt;/code&gt; parameter contains alternating
         * R, G, B values for each color index used in the image.
         * The number of elements must be a multiple of 3 between
         * 3 and 3*256.
         *
         * &lt;p&gt; The 'PLTE' chunk will encode this information.
         *
         * @param rgb An array of &lt;code&gt;int&lt;/code&gt;s.
         */
<span class="nc" id="L167">        public void setPalette(int[] rgb) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1110);</span>
<span class="nc bnc" id="L168" title="All 12 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1111);if ((((rgb.length &lt; 1 * 3 || rgb.length &gt; 256 * 3)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1112)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1113)==0&amp;false))) {{</span>
<span class="nc" id="L169">                __CLR4_5_2u5u5m68iyfte.R.inc(1114);throw new</span>
<span class="nc" id="L170">                  IllegalArgumentException(PropertyUtil.getString(&quot;PNGEncodeParam0&quot;));</span>
            }
<span class="nc bnc" id="L172" title="All 10 branches missed.">            }__CLR4_5_2u5u5m68iyfte.R.inc(1115);if (((((rgb.length % 3) != 0)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1116)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1117)==0&amp;false))) {{</span>
<span class="nc" id="L173">                __CLR4_5_2u5u5m68iyfte.R.inc(1118);throw new</span>
<span class="nc" id="L174">                   IllegalArgumentException(PropertyUtil.getString(&quot;PNGEncodeParam1&quot;));</span>
            }

<span class="nc" id="L177">            }__CLR4_5_2u5u5m68iyfte.R.inc(1119);palette = rgb.clone();</span>
<span class="nc" id="L178">            __CLR4_5_2u5u5m68iyfte.R.inc(1120);paletteSet = true;</span>
<span class="nc" id="L179">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Returns the current RGB palette.
         *
         * &lt;p&gt; If the palette has not previously been set, or has been
         * unset, an &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
         *
         * @throws IllegalStateException if the palette is not set.
         *
         * @return An array of &lt;code&gt;int&lt;/code&gt;s.
         */
<span class="nc" id="L191">        public int[] getPalette() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1121);</span>
<span class="nc bnc" id="L192" title="All 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1122);if ((((!paletteSet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1123)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1124)==0&amp;false))) {{</span>
<span class="nc" id="L193">                __CLR4_5_2u5u5m68iyfte.R.inc(1125);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam3&quot;));</span>
            }
<span class="nc" id="L195">            }__CLR4_5_2u5u5m68iyfte.R.inc(1126);return palette.clone();</span>
<span class="nc" id="L196">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Suppresses the 'PLTE' chunk from being output.
         */
<span class="nc" id="L201">        public void unsetPalette() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1127);</span>
<span class="nc" id="L202">            __CLR4_5_2u5u5m68iyfte.R.inc(1128);palette = null;</span>
<span class="nc" id="L203">            __CLR4_5_2u5u5m68iyfte.R.inc(1129);paletteSet = false;</span>
<span class="nc" id="L204">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Returns true if a 'PLTE' chunk will be output.
         */
<span class="nc" id="L209">        public boolean isPaletteSet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1130);</span>
<span class="nc" id="L210">            __CLR4_5_2u5u5m68iyfte.R.inc(1131);return paletteSet;</span>
<span class="nc" id="L211">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        // bKGD chunk

        private int backgroundPaletteIndex;

        /**
         * Sets the palette index of the suggested background color.
         *
         * &lt;p&gt; The 'bKGD' chunk will encode this information.
         */
<span class="nc" id="L222">        public void setBackgroundPaletteIndex(int index) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1132);</span>
<span class="nc" id="L223">            __CLR4_5_2u5u5m68iyfte.R.inc(1133);backgroundPaletteIndex = index;</span>
<span class="nc" id="L224">            __CLR4_5_2u5u5m68iyfte.R.inc(1134);backgroundSet = true;</span>
<span class="nc" id="L225">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Returns the palette index of the suggested background color.
         *
         * &lt;p&gt; If the background palette index has not previously been
         * set, or has been unset, an
         * &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
         *
         * @throws IllegalStateException if the palette index is not set.
         */
<span class="nc" id="L236">        public int getBackgroundPaletteIndex() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1135);</span>
<span class="nc bnc" id="L237" title="All 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1136);if ((((!backgroundSet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1137)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1138)==0&amp;false))) {{</span>
<span class="nc" id="L238">                __CLR4_5_2u5u5m68iyfte.R.inc(1139);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam4&quot;));</span>
            }
<span class="nc" id="L240">            }__CLR4_5_2u5u5m68iyfte.R.inc(1140);return backgroundPaletteIndex;</span>
<span class="nc" id="L241">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        // tRNS chunk

        private int[] transparency;

        /**
         * Sets the alpha values associated with each palette entry.
         * The &lt;code&gt;alpha&lt;/code&gt; parameter should have as many entries
         * as there are RGB triples in the palette.
         *
         * &lt;p&gt; The 'tRNS' chunk will encode this information.
         */
<span class="nc" id="L254">        public void setPaletteTransparency(byte[] alpha) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1141);</span>
<span class="nc" id="L255">            __CLR4_5_2u5u5m68iyfte.R.inc(1142);transparency = new int[alpha.length];</span>
<span class="nc bnc" id="L256" title="All 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1143);for (int i = 0; (((i &lt; alpha.length)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1144)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1145)==0&amp;false)); i++) {{</span>
<span class="nc" id="L257">                __CLR4_5_2u5u5m68iyfte.R.inc(1146);transparency[i] = alpha[i] &amp; 0xff;</span>
            }
<span class="nc" id="L259">            }__CLR4_5_2u5u5m68iyfte.R.inc(1147);transparencySet = true;</span>
<span class="nc" id="L260">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Returns the alpha values associated with each palette entry.
         *
         * &lt;p&gt; If the palette transparency has not previously been
         * set, or has been unset, an
         * &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
         *
         * @throws IllegalStateException if the palette transparency is
         *        not set.
         */
<span class="nc" id="L272">        public byte[] getPaletteTransparency() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1148);</span>
<span class="nc bnc" id="L273" title="All 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1149);if ((((!transparencySet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1150)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1151)==0&amp;false))) {{</span>
<span class="nc" id="L274">                __CLR4_5_2u5u5m68iyfte.R.inc(1152);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam5&quot;));</span>
            }
<span class="nc" id="L276">            }__CLR4_5_2u5u5m68iyfte.R.inc(1153);byte[] alpha = new byte[transparency.length];</span>
<span class="nc bnc" id="L277" title="All 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1154);for (int i = 0; (((i &lt; alpha.length)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1155)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1156)==0&amp;false)); i++) {{</span>
<span class="nc" id="L278">                __CLR4_5_2u5u5m68iyfte.R.inc(1157);alpha[i] = (byte)transparency[i];</span>
            }
<span class="nc" id="L280">            }__CLR4_5_2u5u5m68iyfte.R.inc(1158);return alpha;</span>
<span class="nc" id="L281">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>
    }

    public static class Gray extends PNGEncodeParam {

        private static final long serialVersionUID = -2055439792025795274L;

        /** Constructs an instance of &lt;code&gt;PNGEncodeParam.Gray&lt;/code&gt;. */
<span class="nc" id="L289">        public Gray() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1159); }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        // bKGD chunk

        private boolean backgroundSet;

        /**
         * Suppresses the 'bKGD' chunk from being output.
         */
<span class="nc" id="L298">        public void unsetBackground() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1160);</span>
<span class="nc" id="L299">            __CLR4_5_2u5u5m68iyfte.R.inc(1161);backgroundSet = false;</span>
<span class="nc" id="L300">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Returns true if a 'bKGD' chunk will be output.
         */
<span class="nc" id="L305">        public boolean isBackgroundSet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1162);</span>
<span class="nc" id="L306">            __CLR4_5_2u5u5m68iyfte.R.inc(1163);return backgroundSet;</span>
<span class="nc" id="L307">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Sets the desired bit depth for a grayscale image.  The bit
         * depth must be one of 1, 2, 4, 8, or 16.
         *
         * &lt;p&gt; When encoding a source image of a greater bit depth,
         * pixel values will be clamped to the smaller range after
         * shifting by the value given by &lt;code&gt;getBitShift()&lt;/code&gt;.
         * When encoding a source image of a smaller bit depth, pixel
         * values will be shifted and left-filled with zeroes.
         */
<span class="nc" id="L319">        public void setBitDepth(int bitDepth) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1164);</span>
<span class="nc bnc" id="L320" title="All 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1165);if ((((bitDepth != 1 &amp;&amp; bitDepth != 2 &amp;&amp; bitDepth != 4</span>
<span class="nc bnc" id="L321" title="All 8 branches missed.">                &amp;&amp; bitDepth != 8 &amp;&amp; bitDepth != 16)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1166)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1167)==0&amp;false))) {{</span>
<span class="nc" id="L322">                __CLR4_5_2u5u5m68iyfte.R.inc(1168);throw new IllegalArgumentException(PropertyUtil.getString(&quot;PNGEncodeParam2&quot;));</span>
            }
<span class="nc" id="L324">            }__CLR4_5_2u5u5m68iyfte.R.inc(1169);this.bitDepth = bitDepth;</span>
<span class="nc" id="L325">            __CLR4_5_2u5u5m68iyfte.R.inc(1170);bitDepthSet = true;</span>
<span class="nc" id="L326">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        // bKGD chunk

        private int backgroundPaletteGray;

        /**
         * Sets the suggested gray level of the background.
         *
         * &lt;p&gt; The 'bKGD' chunk will encode this information.
         */
<span class="nc" id="L337">        public void setBackgroundGray(int gray) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1171);</span>
<span class="nc" id="L338">            __CLR4_5_2u5u5m68iyfte.R.inc(1172);backgroundPaletteGray = gray;</span>
<span class="nc" id="L339">            __CLR4_5_2u5u5m68iyfte.R.inc(1173);backgroundSet = true;</span>
<span class="nc" id="L340">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Returns the suggested gray level of the background.
         *
         * &lt;p&gt; If the background gray level has not previously been
         * set, or has been unset, an
         * &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
         *
         * @throws IllegalStateException if the background gray level
         *        is not set.
         */
<span class="nc" id="L352">        public int getBackgroundGray() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1174);</span>
<span class="nc bnc" id="L353" title="All 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1175);if ((((!backgroundSet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1176)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1177)==0&amp;false))) {{</span>
<span class="nc" id="L354">                __CLR4_5_2u5u5m68iyfte.R.inc(1178);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam6&quot;));</span>
            }
<span class="nc" id="L356">            }__CLR4_5_2u5u5m68iyfte.R.inc(1179);return backgroundPaletteGray;</span>
<span class="nc" id="L357">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        // tRNS chunk

        private int[] transparency;

        /**
         * Sets the gray value to be used to denote transparency.
         *
         * &lt;p&gt; Setting this attribute will cause the alpha channel
         * of the input image to be ignored.
         *
         * &lt;p&gt; The 'tRNS' chunk will encode this information.
         */
<span class="nc" id="L371">        public void setTransparentGray(int transparentGray) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1180);</span>
<span class="nc" id="L372">            __CLR4_5_2u5u5m68iyfte.R.inc(1181);transparency = new int[1];</span>
<span class="nc" id="L373">            __CLR4_5_2u5u5m68iyfte.R.inc(1182);transparency[0] = transparentGray;</span>
<span class="nc" id="L374">            __CLR4_5_2u5u5m68iyfte.R.inc(1183);transparencySet = true;</span>
<span class="nc" id="L375">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Returns the gray value to be used to denote transparency.
         *
         * &lt;p&gt; If the transparent gray value has not previously been
         * set, or has been unset, an
         * &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
         *
         * @throws IllegalStateException if the transparent gray value
         *        is not set.
         */
<span class="nc" id="L387">        public int getTransparentGray() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1184);</span>
<span class="nc bnc" id="L388" title="All 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1185);if ((((!transparencySet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1186)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1187)==0&amp;false))) {{</span>
<span class="nc" id="L389">                __CLR4_5_2u5u5m68iyfte.R.inc(1188);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam7&quot;));</span>
            }
<span class="nc" id="L391">            }__CLR4_5_2u5u5m68iyfte.R.inc(1189);int gray = transparency[0];</span>
<span class="nc" id="L392">            __CLR4_5_2u5u5m68iyfte.R.inc(1190);return gray;</span>
<span class="nc" id="L393">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        private int bitShift;
        private boolean bitShiftSet;

        /**
         * Sets the desired bit shift for a grayscale image.
         * Pixels in the source image will be shifted right by
         * the given amount prior to being clamped to the maximum
         * value given by the encoded image's bit depth.
         */
<span class="nc" id="L404">        public void setBitShift(int bitShift) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1191);</span>
<span class="nc bnc" id="L405" title="All 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1192);if ((((bitShift &lt; 0)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1193)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1194)==0&amp;false))) {{</span>
<span class="nc" id="L406">                __CLR4_5_2u5u5m68iyfte.R.inc(1195);throw new IllegalArgumentException(PropertyUtil.getString(&quot;PNGEncodeParam25&quot;));</span>
            }
<span class="nc" id="L408">            }__CLR4_5_2u5u5m68iyfte.R.inc(1196);this.bitShift = bitShift;</span>
<span class="nc" id="L409">            __CLR4_5_2u5u5m68iyfte.R.inc(1197);bitShiftSet = true;</span>
<span class="nc" id="L410">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Returns the desired bit shift for a grayscale image.
         *
         * &lt;p&gt; If the bit shift has not previously been set, or has been
         * unset, an &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
         *
         * @throws IllegalStateException if the bit shift is not set.
         */
<span class="nc" id="L420">        public int getBitShift() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1198);</span>
<span class="nc bnc" id="L421" title="All 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1199);if ((((!bitShiftSet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1200)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1201)==0&amp;false))) {{</span>
<span class="nc" id="L422">                __CLR4_5_2u5u5m68iyfte.R.inc(1202);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam8&quot;));</span>
            }
<span class="nc" id="L424">            }__CLR4_5_2u5u5m68iyfte.R.inc(1203);return bitShift;</span>
<span class="nc" id="L425">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Suppresses the setting of the bit shift of a grayscale image.
         * Pixels in the source image will not be shifted prior to encoding.
         */
<span class="nc" id="L431">        public void unsetBitShift() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1204);</span>
<span class="nc" id="L432">            __CLR4_5_2u5u5m68iyfte.R.inc(1205);bitShiftSet = false;</span>
<span class="nc" id="L433">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Returns true if the bit shift has been set.
         */
<span class="nc" id="L438">        public boolean isBitShiftSet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1206);</span>
<span class="nc" id="L439">            __CLR4_5_2u5u5m68iyfte.R.inc(1207);return bitShiftSet;</span>
<span class="nc" id="L440">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Returns true if the bit depth has been set.
         */
<span class="nc" id="L445">        public boolean isBitDepthSet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1208);</span>
<span class="nc" id="L446">            __CLR4_5_2u5u5m68iyfte.R.inc(1209);return bitDepthSet;</span>
<span class="nc" id="L447">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>
    }

    public static class RGB extends PNGEncodeParam {

        private static final long serialVersionUID = -8918762026006670891L;

        /** Constructs an instance of &lt;code&gt;PNGEncodeParam.RGB&lt;/code&gt;. */
<span class="fc" id="L455">        public RGB() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1210); }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        // bKGD chunk

        private boolean backgroundSet;

        /**
         * Suppresses the 'bKGD' chunk from being output.
         */
<span class="nc" id="L464">        public void unsetBackground() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1211);</span>
<span class="nc" id="L465">            __CLR4_5_2u5u5m68iyfte.R.inc(1212);backgroundSet = false;</span>
<span class="nc" id="L466">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Returns true if a 'bKGD' chunk will be output.
         */
<span class="fc" id="L471">        public boolean isBackgroundSet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1213);</span>
<span class="fc" id="L472">            __CLR4_5_2u5u5m68iyfte.R.inc(1214);return backgroundSet;</span>
<span class="fc" id="L473">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Sets the desired bit depth for an RGB image.  The bit
         * depth must be 8 or 16.
         */
<span class="nc" id="L479">        public void setBitDepth(int bitDepth) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1215);</span>
<span class="nc bnc" id="L480" title="All 12 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1216);if ((((bitDepth != 8 &amp;&amp; bitDepth != 16)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1217)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1218)==0&amp;false))) {{</span>
<span class="nc" id="L481">                __CLR4_5_2u5u5m68iyfte.R.inc(1219);throw new IllegalArgumentException(PropertyUtil.getString(&quot;PNGEncodeParam26&quot;));</span>
            }
<span class="nc" id="L483">            }__CLR4_5_2u5u5m68iyfte.R.inc(1220);this.bitDepth = bitDepth;</span>
<span class="nc" id="L484">            __CLR4_5_2u5u5m68iyfte.R.inc(1221);bitDepthSet = true;</span>
<span class="nc" id="L485">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        // bKGD chunk

        private int[] backgroundRGB;

        /**
         * Sets the RGB value of the suggested background color.
         * The &lt;code&gt;rgb&lt;/code&gt; parameter should have 3 entries.
         *
         * &lt;p&gt; The 'bKGD' chunk will encode this information.
         */
<span class="nc" id="L497">        public void setBackgroundRGB(int[] rgb) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1222);</span>
<span class="nc bnc" id="L498" title="All 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1223);if ((((rgb.length != 3)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1224)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1225)==0&amp;false))) {{</span>
<span class="nc" id="L499">                __CLR4_5_2u5u5m68iyfte.R.inc(1226);throw new IllegalArgumentException(PropertyUtil.getString(&quot;PNGEncodeParam27&quot;));</span>
            }
<span class="nc" id="L501">            }__CLR4_5_2u5u5m68iyfte.R.inc(1227);backgroundRGB = rgb;</span>
<span class="nc" id="L502">            __CLR4_5_2u5u5m68iyfte.R.inc(1228);backgroundSet = true;</span>
<span class="nc" id="L503">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Returns the RGB value of the suggested background color.
         *
         * &lt;p&gt; If the background color has not previously been set, or has been
         * unset, an &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
         *
         * @throws IllegalStateException if the background color is not set.
         */
<span class="nc" id="L513">        public int[] getBackgroundRGB() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1229);</span>
<span class="nc bnc" id="L514" title="All 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1230);if ((((!backgroundSet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1231)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1232)==0&amp;false))) {{</span>
<span class="nc" id="L515">                __CLR4_5_2u5u5m68iyfte.R.inc(1233);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam9&quot;));</span>
            }
<span class="nc" id="L517">            }__CLR4_5_2u5u5m68iyfte.R.inc(1234);return backgroundRGB;</span>
<span class="nc" id="L518">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        // tRNS chunk

        private int[] transparency;

        /**
         * Sets the RGB value to be used to denote transparency.
         *
         * &lt;p&gt; Setting this attribute will cause the alpha channel
         * of the input image to be ignored.
         *
         * &lt;p&gt; The 'tRNS' chunk will encode this information.
         */
<span class="nc" id="L532">        public void setTransparentRGB(int[] transparentRGB) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1235);</span>
<span class="nc" id="L533">            __CLR4_5_2u5u5m68iyfte.R.inc(1236);transparency = transparentRGB.clone();</span>
<span class="nc" id="L534">            __CLR4_5_2u5u5m68iyfte.R.inc(1237);transparencySet = true;</span>
<span class="nc" id="L535">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

        /**
         * Returns the RGB value to be used to denote transparency.
         *
         * &lt;p&gt; If the transparent color has not previously been set,
         * or has been unset, an &lt;code&gt;IllegalStateException&lt;/code&gt;
         * will be thrown.
         *
         * @throws IllegalStateException if the transparent color is not set.
         */
<span class="nc" id="L546">        public int[] getTransparentRGB() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1238);</span>
<span class="nc bnc" id="L547" title="All 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1239);if ((((!transparencySet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1240)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1241)==0&amp;false))) {{</span>
<span class="nc" id="L548">                __CLR4_5_2u5u5m68iyfte.R.inc(1242);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam10&quot;));</span>
            }
<span class="nc" id="L550">            }__CLR4_5_2u5u5m68iyfte.R.inc(1243);return transparency.clone();</span>
<span class="nc" id="L551">        }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>
    }

    protected int bitDepth;
    protected boolean bitDepthSet;

    /**
     * Sets the desired bit depth of an image.
     */
    public abstract void setBitDepth(int bitDepth);

    /**
     * Returns the desired bit depth for a grayscale image.
     *
     * &lt;p&gt; If the bit depth has not previously been set, or has been
     * unset, an &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
     *
     * @throws IllegalStateException if the bit depth is not set.
     */
<span class="nc" id="L570">    public int getBitDepth() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1244);</span>
<span class="nc bnc" id="L571" title="All 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1245);if ((((!bitDepthSet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1246)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1247)==0&amp;false))) {{</span>
<span class="nc" id="L572">            __CLR4_5_2u5u5m68iyfte.R.inc(1248);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam11&quot;));</span>
        }
<span class="nc" id="L574">        }__CLR4_5_2u5u5m68iyfte.R.inc(1249);return bitDepth;</span>
<span class="nc" id="L575">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Suppresses the setting of the bit depth of a grayscale image.
     * The depth of the encoded image will be inferred from the source
     * image bit depth, rounded up to the next power of 2 between 1
     * and 16.
     */
<span class="nc" id="L583">    public void unsetBitDepth() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1250);</span>
<span class="nc" id="L584">        __CLR4_5_2u5u5m68iyfte.R.inc(1251);bitDepthSet = false;</span>
<span class="nc" id="L585">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    private boolean useInterlacing;

    /**
     * Turns Adam7 interlacing on or off.
     */
<span class="nc" id="L592">    public void setInterlacing(boolean useInterlacing) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1252);</span>
<span class="nc" id="L593">        __CLR4_5_2u5u5m68iyfte.R.inc(1253);this.useInterlacing = useInterlacing;</span>
<span class="nc" id="L594">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if Adam7 interlacing will be used.
     */
<span class="fc" id="L599">    public boolean getInterlacing() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1254);</span>
<span class="fc" id="L600">        __CLR4_5_2u5u5m68iyfte.R.inc(1255);return useInterlacing;</span>
<span class="fc" id="L601">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    // bKGD chunk - delegate to subclasses

    // In JAI 1.0, 'backgroundSet' was private.  The JDK 1.2 compiler
    // was lenient and incorrectly allowed this variable to be
    // accessed from the subclasses.  The JDK 1.3 compiler correctly
    // flags this as a use of a non-static variable in a static
    // context.  Changing 'backgroundSet' to protected would have
    // solved the problem, but would have introduced a visible API
    // change.  Thus we are forced to adopt the solution of placing a
    // separate private variable in each subclass and providing
    // separate implementations of 'unsetBackground' and
    // 'isBackgroundSet' in each concrete subclass.

    /**
     * Suppresses the 'bKGD' chunk from being output.
     * For API compatibility with JAI 1.0, the superclass
     * defines this method to throw a &lt;code&gt;RuntimeException&lt;/code&gt;;
     * accordingly, subclasses must provide their own implementations.
     */
<span class="nc" id="L622">    public void unsetBackground() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1256);</span>
<span class="nc" id="L623">        __CLR4_5_2u5u5m68iyfte.R.inc(1257);throw new RuntimeException(PropertyUtil.getString(&quot;PNGEncodeParam23&quot;));</span>
<span class="nc" id="L624">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns true if a 'bKGD' chunk will be output.
     * For API compatibility with JAI 1.0, the superclass
     * defines this method to throw a &lt;code&gt;RuntimeException&lt;/code&gt;;
     * accordingly, subclasses must provide their own implementations.
     */
<span class="nc" id="L632">    public boolean isBackgroundSet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1258);</span>
<span class="nc" id="L633">        __CLR4_5_2u5u5m68iyfte.R.inc(1259);throw new RuntimeException(PropertyUtil.getString(&quot;PNGEncodeParam24&quot;));</span>
<span class="nc" id="L634">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    // cHRM chunk

    private float[] chromaticity;
    private boolean chromaticitySet;

    /**
     * Sets the white point and primary chromaticities in CIE (x, y)
     * space.
     *
     * &lt;p&gt; The &lt;code&gt;chromaticity&lt;/code&gt; parameter should be a
     * &lt;code&gt;float&lt;/code&gt; array of length 8 containing the white point
     * X and Y, red X and Y, green X and Y, and blue X and Y values in
     * order.
     *
     * &lt;p&gt; The 'cHRM' chunk will encode this information.
     */
<span class="nc" id="L652">    public void setChromaticity(float[] chromaticity) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1260);</span>
<span class="nc bnc" id="L653" title="All 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1261);if ((((chromaticity.length != 8)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1262)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1263)==0&amp;false))) {{</span>
<span class="nc" id="L654">            __CLR4_5_2u5u5m68iyfte.R.inc(1264);throw new IllegalArgumentException(PropertyUtil.getString(&quot;PNGEncodeParam28&quot;));</span>
        }
<span class="nc" id="L656">        }__CLR4_5_2u5u5m68iyfte.R.inc(1265);this.chromaticity = chromaticity.clone();</span>
<span class="nc" id="L657">        __CLR4_5_2u5u5m68iyfte.R.inc(1266);chromaticitySet = true;</span>
<span class="nc" id="L658">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * A convenience method that calls the array version.
     */
    public void setChromaticity(float whitePointX, float whitePointY,
                                float redX, float redY,
                                float greenX, float greenY,
<span class="nc" id="L666">                                float blueX, float blueY) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1267);</span>
<span class="nc" id="L667">        __CLR4_5_2u5u5m68iyfte.R.inc(1268);float[] chroma = new float[8];</span>
<span class="nc" id="L668">        __CLR4_5_2u5u5m68iyfte.R.inc(1269);chroma[0] = whitePointX;</span>
<span class="nc" id="L669">        __CLR4_5_2u5u5m68iyfte.R.inc(1270);chroma[1] = whitePointY;</span>
<span class="nc" id="L670">        __CLR4_5_2u5u5m68iyfte.R.inc(1271);chroma[2] = redX;</span>
<span class="nc" id="L671">        __CLR4_5_2u5u5m68iyfte.R.inc(1272);chroma[3] = redY;</span>
<span class="nc" id="L672">        __CLR4_5_2u5u5m68iyfte.R.inc(1273);chroma[4] = greenX;</span>
<span class="nc" id="L673">        __CLR4_5_2u5u5m68iyfte.R.inc(1274);chroma[5] = greenY;</span>
<span class="nc" id="L674">        __CLR4_5_2u5u5m68iyfte.R.inc(1275);chroma[6] = blueX;</span>
<span class="nc" id="L675">        __CLR4_5_2u5u5m68iyfte.R.inc(1276);chroma[7] = blueY;</span>
<span class="nc" id="L676">        __CLR4_5_2u5u5m68iyfte.R.inc(1277);setChromaticity(chroma);</span>
<span class="nc" id="L677">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns the white point and primary chromaticities in
     * CIE (x, y) space.
     *
     * &lt;p&gt; See the documentation for the &lt;code&gt;setChromaticity&lt;/code&gt;
     * method for the format of the returned data.
     *
     * &lt;p&gt; If the chromaticity has not previously been set, or has been
     * unset, an &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
     *
     * @throws IllegalStateException if the chromaticity is not set.
     */
<span class="nc" id="L691">    public float[] getChromaticity() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1278);</span>
<span class="nc bnc" id="L692" title="All 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1279);if ((((!chromaticitySet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1280)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1281)==0&amp;false))) {{</span>
<span class="nc" id="L693">            __CLR4_5_2u5u5m68iyfte.R.inc(1282);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam12&quot;));</span>
        }
<span class="nc" id="L695">        }__CLR4_5_2u5u5m68iyfte.R.inc(1283);return chromaticity.clone();</span>
<span class="nc" id="L696">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Suppresses the 'cHRM' chunk from being output.
     */
<span class="nc" id="L701">    public void unsetChromaticity() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1284);</span>
<span class="nc" id="L702">        __CLR4_5_2u5u5m68iyfte.R.inc(1285);chromaticity = null;</span>
<span class="nc" id="L703">        __CLR4_5_2u5u5m68iyfte.R.inc(1286);chromaticitySet = false;</span>
<span class="nc" id="L704">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns true if a 'cHRM' chunk will be output.
     */
<span class="fc" id="L709">    public boolean isChromaticitySet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1287);</span>
<span class="fc" id="L710">        __CLR4_5_2u5u5m68iyfte.R.inc(1288);return chromaticitySet;</span>
<span class="fc" id="L711">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    // gAMA chunk

    private float gamma;
    private boolean gammaSet;

    /**
     * Sets the file gamma value for the image.
     *
     * &lt;p&gt; The 'gAMA' chunk will encode this information.
     */
<span class="nc" id="L723">    public void setGamma(float gamma) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1289);</span>
<span class="nc" id="L724">        __CLR4_5_2u5u5m68iyfte.R.inc(1290);this.gamma = gamma;</span>
<span class="nc" id="L725">        __CLR4_5_2u5u5m68iyfte.R.inc(1291);gammaSet = true;</span>
<span class="nc" id="L726">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns the file gamma value for the image.
     *
     * &lt;p&gt; If the file gamma has not previously been set, or has been
     * unset, an &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
     *
     * @throws IllegalStateException if the gamma is not set.
     */
<span class="nc" id="L736">    public float getGamma() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1292);</span>
<span class="nc bnc" id="L737" title="All 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1293);if ((((!gammaSet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1294)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1295)==0&amp;false))) {{</span>
<span class="nc" id="L738">            __CLR4_5_2u5u5m68iyfte.R.inc(1296);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam13&quot;));</span>
        }
<span class="nc" id="L740">        }__CLR4_5_2u5u5m68iyfte.R.inc(1297);return gamma;</span>
<span class="nc" id="L741">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Suppresses the 'gAMA' chunk from being output.
     */
<span class="nc" id="L746">    public void unsetGamma() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1298);</span>
<span class="nc" id="L747">        __CLR4_5_2u5u5m68iyfte.R.inc(1299);gammaSet = false;</span>
<span class="nc" id="L748">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns true if a 'gAMA' chunk will be output.
     */
<span class="fc" id="L753">    public boolean isGammaSet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1300);</span>
<span class="fc" id="L754">        __CLR4_5_2u5u5m68iyfte.R.inc(1301);return gammaSet;</span>
<span class="fc" id="L755">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    // hIST chunk

    private int[] paletteHistogram;
    private boolean paletteHistogramSet;

    /**
     * Sets the palette histogram to be stored with this image.
     * The histogram consists of an array of integers, one per
     * palette entry.
     *
     * &lt;p&gt; The 'hIST' chunk will encode this information.
     */
<span class="nc" id="L769">    public void setPaletteHistogram(int[] paletteHistogram) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1302);</span>
<span class="nc" id="L770">        __CLR4_5_2u5u5m68iyfte.R.inc(1303);this.paletteHistogram = paletteHistogram.clone();</span>
<span class="nc" id="L771">        __CLR4_5_2u5u5m68iyfte.R.inc(1304);paletteHistogramSet = true;</span>
<span class="nc" id="L772">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns the palette histogram to be stored with this image.
     *
     * &lt;p&gt; If the histogram has not previously been set, or has been
     * unset, an &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
     *
     * @throws IllegalStateException if the histogram is not set.
     */
<span class="nc" id="L782">    public int[] getPaletteHistogram() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1305);</span>
<span class="nc bnc" id="L783" title="All 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1306);if ((((!paletteHistogramSet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1307)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1308)==0&amp;false))) {{</span>
<span class="nc" id="L784">            __CLR4_5_2u5u5m68iyfte.R.inc(1309);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam14&quot;));</span>
        }
<span class="nc" id="L786">        }__CLR4_5_2u5u5m68iyfte.R.inc(1310);return paletteHistogram;</span>
<span class="nc" id="L787">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Suppresses the 'hIST' chunk from being output.
     */
<span class="nc" id="L792">    public void unsetPaletteHistogram() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1311);</span>
<span class="nc" id="L793">        __CLR4_5_2u5u5m68iyfte.R.inc(1312);paletteHistogram = null;</span>
<span class="nc" id="L794">        __CLR4_5_2u5u5m68iyfte.R.inc(1313);paletteHistogramSet = false;</span>
<span class="nc" id="L795">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns true if a 'hIST' chunk will be output.
     */
<span class="fc" id="L800">    public boolean isPaletteHistogramSet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1314);</span>
<span class="fc" id="L801">        __CLR4_5_2u5u5m68iyfte.R.inc(1315);return paletteHistogramSet;</span>
<span class="fc" id="L802">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    // iCCP chunk

    private byte[] iccProfileData;
    private boolean iccProfileDataSet;

    /**
     * Sets the ICC profile data to be stored with this image.
     * The profile is represented in raw binary form.
     *
     * &lt;p&gt; The 'iCCP' chunk will encode this information.
     */
<span class="nc" id="L815">    public void setICCProfileData(byte[] iccProfileData) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1316);</span>
<span class="nc" id="L816">        __CLR4_5_2u5u5m68iyfte.R.inc(1317);this.iccProfileData = iccProfileData.clone();</span>
<span class="nc" id="L817">        __CLR4_5_2u5u5m68iyfte.R.inc(1318);iccProfileDataSet = true;</span>
<span class="nc" id="L818">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns the ICC profile data to be stored with this image.
     *
     * &lt;p&gt; If the ICC profile has not previously been set, or has been
     * unset, an &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
     *
     * @throws IllegalStateException if the ICC profile is not set.
     */
<span class="nc" id="L828">    public byte[] getICCProfileData() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1319);</span>
<span class="nc bnc" id="L829" title="All 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1320);if ((((!iccProfileDataSet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1321)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1322)==0&amp;false))) {{</span>
<span class="nc" id="L830">            __CLR4_5_2u5u5m68iyfte.R.inc(1323);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam15&quot;));</span>
        }
<span class="nc" id="L832">        }__CLR4_5_2u5u5m68iyfte.R.inc(1324);return iccProfileData.clone();</span>
<span class="nc" id="L833">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Suppresses the 'iCCP' chunk from being output.
     */
<span class="nc" id="L838">    public void unsetICCProfileData() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1325);</span>
<span class="nc" id="L839">        __CLR4_5_2u5u5m68iyfte.R.inc(1326);iccProfileData = null;</span>
<span class="nc" id="L840">        __CLR4_5_2u5u5m68iyfte.R.inc(1327);iccProfileDataSet = false;</span>
<span class="nc" id="L841">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns true if a 'iCCP' chunk will be output.
     */
<span class="fc" id="L846">    public boolean isICCProfileDataSet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1328);</span>
<span class="fc" id="L847">        __CLR4_5_2u5u5m68iyfte.R.inc(1329);return iccProfileDataSet;</span>
<span class="fc" id="L848">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    // pHYS chunk

    private int[] physicalDimension;
    private boolean physicalDimensionSet;

    /**
     * Sets the physical dimension information to be stored with this
     * image.  The physicalDimension parameter should be a 3-entry
     * array containing the number of pixels per unit in the X
     * direction, the number of pixels per unit in the Y direction,
     * and the unit specifier (0 = unknown, 1 = meters).
     *
     * &lt;p&gt; The 'pHYS' chunk will encode this information.
     */
<span class="nc" id="L864">    public void setPhysicalDimension(int[] physicalDimension) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1330);</span>
<span class="nc" id="L865">        __CLR4_5_2u5u5m68iyfte.R.inc(1331);this.physicalDimension = physicalDimension.clone();</span>
<span class="nc" id="L866">        __CLR4_5_2u5u5m68iyfte.R.inc(1332);physicalDimensionSet = true;</span>
<span class="nc" id="L867">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * A convenience method that calls the array version.
     */
    public void setPhysicalDimension(int xPixelsPerUnit,
                                     int yPixelsPerUnit,
<span class="nc" id="L874">                                     int unitSpecifier) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1333);</span>
<span class="nc" id="L875">        __CLR4_5_2u5u5m68iyfte.R.inc(1334);int[] pd = new int[3];</span>
<span class="nc" id="L876">        __CLR4_5_2u5u5m68iyfte.R.inc(1335);pd[0] = xPixelsPerUnit;</span>
<span class="nc" id="L877">        __CLR4_5_2u5u5m68iyfte.R.inc(1336);pd[1] = yPixelsPerUnit;</span>
<span class="nc" id="L878">        __CLR4_5_2u5u5m68iyfte.R.inc(1337);pd[2] = unitSpecifier;</span>

<span class="nc" id="L880">        __CLR4_5_2u5u5m68iyfte.R.inc(1338);setPhysicalDimension(pd);</span>
<span class="nc" id="L881">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns the physical dimension information to be stored
     * with this image.
     *
     * &lt;p&gt; If the physical dimension information has not previously
     * been set, or has been unset, an
     * &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
     *
     * @throws IllegalStateException if the physical dimension information
     *        is not set.
     */
<span class="nc" id="L894">    public int[] getPhysicalDimension() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1339);</span>
<span class="nc bnc" id="L895" title="All 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1340);if ((((!physicalDimensionSet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1341)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1342)==0&amp;false))) {{</span>
<span class="nc" id="L896">            __CLR4_5_2u5u5m68iyfte.R.inc(1343);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam16&quot;));</span>
        }
<span class="nc" id="L898">        }__CLR4_5_2u5u5m68iyfte.R.inc(1344);return physicalDimension.clone();</span>
<span class="nc" id="L899">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Suppresses the 'pHYS' chunk from being output.
     */
<span class="nc" id="L904">    public void unsetPhysicalDimension() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1345);</span>
<span class="nc" id="L905">        __CLR4_5_2u5u5m68iyfte.R.inc(1346);physicalDimension = null;</span>
<span class="nc" id="L906">        __CLR4_5_2u5u5m68iyfte.R.inc(1347);physicalDimensionSet = false;</span>
<span class="nc" id="L907">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns true if a 'pHYS' chunk will be output.
     */
<span class="fc" id="L912">    public boolean isPhysicalDimensionSet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1348);</span>
<span class="fc" id="L913">        __CLR4_5_2u5u5m68iyfte.R.inc(1349);return physicalDimensionSet;</span>
<span class="fc" id="L914">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    // sPLT chunk

    private PNGSuggestedPaletteEntry[] suggestedPalette;
    private boolean suggestedPaletteSet;

    /**
     * Sets the suggested palette information to be stored with this
     * image.  The information is passed to this method as an array of
     * &lt;code&gt;PNGSuggestedPaletteEntry&lt;/code&gt; objects.
     *
     * &lt;p&gt; The 'sPLT' chunk will encode this information.
     */
<span class="nc" id="L928">    public void setSuggestedPalette(PNGSuggestedPaletteEntry[] palette) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1350);</span>
<span class="nc" id="L929">        __CLR4_5_2u5u5m68iyfte.R.inc(1351);suggestedPalette = palette.clone();</span>
<span class="nc" id="L930">        __CLR4_5_2u5u5m68iyfte.R.inc(1352);suggestedPaletteSet = true;</span>
<span class="nc" id="L931">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns the suggested palette information to be stored with this
     * image.
     *
     * &lt;p&gt; If the suggested palette information has not previously
     * been set, or has been unset, an
     * &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
     *
     * @throws IllegalStateException if the suggested palette
     *        information is not set.
     */
<span class="nc" id="L944">    public PNGSuggestedPaletteEntry[] getSuggestedPalette() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1353);</span>
<span class="nc bnc" id="L945" title="All 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1354);if ((((!suggestedPaletteSet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1355)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1356)==0&amp;false))) {{</span>
<span class="nc" id="L946">            __CLR4_5_2u5u5m68iyfte.R.inc(1357);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam17&quot;));</span>
        }
<span class="nc" id="L948">        }__CLR4_5_2u5u5m68iyfte.R.inc(1358);return suggestedPalette.clone();</span>
<span class="nc" id="L949">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Suppresses the 'sPLT' chunk from being output.
     */
<span class="nc" id="L954">    public void unsetSuggestedPalette() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1359);</span>
<span class="nc" id="L955">        __CLR4_5_2u5u5m68iyfte.R.inc(1360);suggestedPalette = null;</span>
<span class="nc" id="L956">        __CLR4_5_2u5u5m68iyfte.R.inc(1361);suggestedPaletteSet = false;</span>
<span class="nc" id="L957">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns true if a 'sPLT' chunk will be output.
     */
<span class="fc" id="L962">    public boolean isSuggestedPaletteSet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1362);</span>
<span class="fc" id="L963">        __CLR4_5_2u5u5m68iyfte.R.inc(1363);return suggestedPaletteSet;</span>
<span class="fc" id="L964">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    // sBIT chunk

    private int[] significantBits;
    private boolean significantBitsSet;

    /**
     * Sets the number of significant bits for each band of the image.
     *
     * &lt;p&gt; The number of entries in the &lt;code&gt;significantBits&lt;/code&gt;
     * array must be equal to the number of output bands in the image:
     * 1 for a gray image, 2 for gray+alpha, 3 for index or truecolor,
     * and 4 for truecolor+alpha.
     *
     * &lt;p&gt; The 'sBIT' chunk will encode this information.
     */
<span class="nc" id="L981">    public void setSignificantBits(int[] significantBits) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1364);</span>
<span class="nc" id="L982">        __CLR4_5_2u5u5m68iyfte.R.inc(1365);this.significantBits = significantBits.clone();</span>
<span class="nc" id="L983">        __CLR4_5_2u5u5m68iyfte.R.inc(1366);significantBitsSet = true;</span>
<span class="nc" id="L984">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns the number of significant bits for each band of the image.
     *
     * &lt;p&gt; If the significant bits values have not previously been
     * set, or have been unset, an &lt;code&gt;IllegalStateException&lt;/code&gt;
     * will be thrown.
     *
     * @throws IllegalStateException if the significant bits values are
     *        not set.
     */
<span class="nc" id="L996">    public int[] getSignificantBits() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1367);</span>
<span class="nc bnc" id="L997" title="All 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1368);if ((((!significantBitsSet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1369)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1370)==0&amp;false))) {{</span>
<span class="nc" id="L998">            __CLR4_5_2u5u5m68iyfte.R.inc(1371);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam18&quot;));</span>
        }
<span class="nc" id="L1000">        }__CLR4_5_2u5u5m68iyfte.R.inc(1372);return significantBits.clone();</span>
<span class="nc" id="L1001">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Suppresses the 'sBIT' chunk from being output.
     */
<span class="nc" id="L1006">    public void unsetSignificantBits() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1373);</span>
<span class="nc" id="L1007">        __CLR4_5_2u5u5m68iyfte.R.inc(1374);significantBits = null;</span>
<span class="nc" id="L1008">        __CLR4_5_2u5u5m68iyfte.R.inc(1375);significantBitsSet = false;</span>
<span class="nc" id="L1009">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns true if an 'sBIT' chunk will be output.
     */
<span class="fc" id="L1014">    public boolean isSignificantBitsSet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1376);</span>
<span class="fc" id="L1015">        __CLR4_5_2u5u5m68iyfte.R.inc(1377);return significantBitsSet;</span>
<span class="fc" id="L1016">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    // sRGB chunk

    private int srgbIntent;
    private boolean srgbIntentSet;

    /**
     * Sets the sRGB rendering intent to be stored with this image.
     * The legal values are 0 = Perceptual, 1 = Relative Colorimetric,
     * 2 = Saturation, and 3 = Absolute Colorimetric.  Refer to the
     * PNG specification for information on these values.
     *
     * &lt;p&gt; The 'sRGB' chunk will encode this information.
     */
<span class="nc" id="L1031">    public void setSRGBIntent(int srgbIntent) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1378);</span>
<span class="nc" id="L1032">        __CLR4_5_2u5u5m68iyfte.R.inc(1379);this.srgbIntent = srgbIntent;</span>
<span class="nc" id="L1033">        __CLR4_5_2u5u5m68iyfte.R.inc(1380);srgbIntentSet = true;</span>
<span class="nc" id="L1034">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns the sRGB rendering intent to be stored with this image.
     *
     * &lt;p&gt; If the sRGB intent has not previously been set, or has been
     * unset, an &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
     *
     * @throws IllegalStateException if the sRGB intent is not set.
     */
<span class="nc" id="L1044">    public int getSRGBIntent() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1381);</span>
<span class="nc bnc" id="L1045" title="All 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1382);if ((((!srgbIntentSet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1383)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1384)==0&amp;false))) {{</span>
<span class="nc" id="L1046">            __CLR4_5_2u5u5m68iyfte.R.inc(1385);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam19&quot;));</span>
        }
<span class="nc" id="L1048">        }__CLR4_5_2u5u5m68iyfte.R.inc(1386);return srgbIntent;</span>
<span class="nc" id="L1049">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Suppresses the 'sRGB' chunk from being output.
     */
<span class="nc" id="L1054">    public void unsetSRGBIntent() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1387);</span>
<span class="nc" id="L1055">        __CLR4_5_2u5u5m68iyfte.R.inc(1388);srgbIntentSet = false;</span>
<span class="nc" id="L1056">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns true if an 'sRGB' chunk will be output.
     */
<span class="fc" id="L1061">    public boolean isSRGBIntentSet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1389);</span>
<span class="fc" id="L1062">        __CLR4_5_2u5u5m68iyfte.R.inc(1390);return srgbIntentSet;</span>
<span class="fc" id="L1063">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    // tEXt chunk

    private String[] text;
    private boolean textSet;

    /**
     * Sets the textual data to be stored in uncompressed form with this
     * image.  The data is passed to this method as an array of
     * &lt;code&gt;String&lt;/code&gt;s.
     *
     * &lt;p&gt; The 'tEXt' chunk will encode this information.
     */
<span class="nc" id="L1077">    public void setText(String[] text) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1391);</span>
<span class="nc" id="L1078">        __CLR4_5_2u5u5m68iyfte.R.inc(1392);this.text = text;</span>
<span class="nc" id="L1079">        __CLR4_5_2u5u5m68iyfte.R.inc(1393);textSet = true;</span>
<span class="nc" id="L1080">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns the text strings to be stored in uncompressed form with this
     * image as an array of &lt;code&gt;String&lt;/code&gt;s.
     *
     * &lt;p&gt; If the text strings have not previously been set, or have been
     * unset, an &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
     *
     * @throws IllegalStateException if the text strings are not set.
     */
<span class="nc" id="L1091">    public String[] getText() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1394);</span>
<span class="nc bnc" id="L1092" title="All 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1395);if ((((!textSet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1396)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1397)==0&amp;false))) {{</span>
<span class="nc" id="L1093">            __CLR4_5_2u5u5m68iyfte.R.inc(1398);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam20&quot;));</span>
        }
<span class="nc" id="L1095">        }__CLR4_5_2u5u5m68iyfte.R.inc(1399);return text;</span>
<span class="nc" id="L1096">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Suppresses the 'tEXt' chunk from being output.
     */
<span class="nc" id="L1101">    public void unsetText() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1400);</span>
<span class="nc" id="L1102">        __CLR4_5_2u5u5m68iyfte.R.inc(1401);text = null;</span>
<span class="nc" id="L1103">        __CLR4_5_2u5u5m68iyfte.R.inc(1402);textSet = false;</span>
<span class="nc" id="L1104">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns true if a 'tEXt' chunk will be output.
     */
<span class="fc" id="L1109">    public boolean isTextSet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1403);</span>
<span class="fc" id="L1110">        __CLR4_5_2u5u5m68iyfte.R.inc(1404);return textSet;</span>
<span class="fc" id="L1111">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    // tIME chunk

    private Date modificationTime;
    private boolean modificationTimeSet;

    /**
     * Sets the modification time, as a &lt;code&gt;Date&lt;/code&gt;, to be
     * stored with this image.  The internal storage format will use
     * UTC regardless of how the &lt;code&gt;modificationTime&lt;/code&gt;
     * parameter was created.
     *
     * &lt;p&gt; The 'tIME' chunk will encode this information.
     */
<span class="nc" id="L1126">    public void setModificationTime(Date modificationTime) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1405);</span>
<span class="nc" id="L1127">        __CLR4_5_2u5u5m68iyfte.R.inc(1406);this.modificationTime = modificationTime;</span>
<span class="nc" id="L1128">        __CLR4_5_2u5u5m68iyfte.R.inc(1407);modificationTimeSet = true;</span>
<span class="nc" id="L1129">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns the modification time to be stored with this image.
     *
     * &lt;p&gt; If the bit depth has not previously been set, or has been
     * unset, an &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.
     *
     * @throws IllegalStateException if the bit depth is not set.
     */
<span class="nc" id="L1139">    public Date getModificationTime() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1408);</span>
<span class="nc bnc" id="L1140" title="All 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1409);if ((((!modificationTimeSet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1410)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1411)==0&amp;false))) {{</span>
<span class="nc" id="L1141">            __CLR4_5_2u5u5m68iyfte.R.inc(1412);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam21&quot;));</span>
        }
<span class="nc" id="L1143">        }__CLR4_5_2u5u5m68iyfte.R.inc(1413);return modificationTime;</span>
<span class="nc" id="L1144">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Suppresses the 'tIME' chunk from being output.
     */
<span class="nc" id="L1149">    public void unsetModificationTime() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1414);</span>
<span class="nc" id="L1150">        __CLR4_5_2u5u5m68iyfte.R.inc(1415);modificationTime = null;</span>
<span class="nc" id="L1151">        __CLR4_5_2u5u5m68iyfte.R.inc(1416);modificationTimeSet = false;</span>
<span class="nc" id="L1152">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns true if a 'tIME' chunk will be output.
     */
<span class="fc" id="L1157">    public boolean isModificationTimeSet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1417);</span>
<span class="fc" id="L1158">        __CLR4_5_2u5u5m68iyfte.R.inc(1418);return modificationTimeSet;</span>
<span class="fc" id="L1159">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    // tRNS chunk

    boolean transparencySet;

    /**
     * Suppresses the 'tRNS' chunk from being output.
     */
<span class="nc" id="L1168">    public void unsetTransparency() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1419);</span>
<span class="nc" id="L1169">        __CLR4_5_2u5u5m68iyfte.R.inc(1420);transparencySet = false;</span>
<span class="nc" id="L1170">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns true if a 'tRNS' chunk will be output.
     */
<span class="fc" id="L1175">    public boolean isTransparencySet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1421);</span>
<span class="fc" id="L1176">        __CLR4_5_2u5u5m68iyfte.R.inc(1422);return transparencySet;</span>
<span class="fc" id="L1177">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    // zTXT chunk

    private String[] zText;
    private boolean zTextSet;

    /**
     * Sets the text strings to be stored in compressed form with this
     * image.  The data is passed to this method as an array of
     * &lt;code&gt;String&lt;/code&gt;s.
     *
     * &lt;p&gt; The 'zTXt' chunk will encode this information.
     */
<span class="nc" id="L1191">    public void setCompressedText(String[] text) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1423);</span>
<span class="nc" id="L1192">        __CLR4_5_2u5u5m68iyfte.R.inc(1424);this.zText = text;</span>
<span class="nc" id="L1193">        __CLR4_5_2u5u5m68iyfte.R.inc(1425);zTextSet = true;</span>
<span class="nc" id="L1194">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns the text strings to be stored in compressed form with
     * this image as an array of &lt;code&gt;String&lt;/code&gt;s.
     *
     * &lt;p&gt; If the compressed text strings have not previously been
     * set, or have been unset, an &lt;code&gt;IllegalStateException&lt;/code&gt;
     * will be thrown.
     *
     * @throws IllegalStateException if the compressed text strings are
     *        not set.
     */
<span class="nc" id="L1207">    public String[] getCompressedText() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1426);</span>
<span class="nc bnc" id="L1208" title="All 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1427);if ((((!zTextSet)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1428)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1429)==0&amp;false))) {{</span>
<span class="nc" id="L1209">            __CLR4_5_2u5u5m68iyfte.R.inc(1430);throw new IllegalStateException(PropertyUtil.getString(&quot;PNGEncodeParam22&quot;));</span>
        }
<span class="nc" id="L1211">        }__CLR4_5_2u5u5m68iyfte.R.inc(1431);return zText;</span>
<span class="nc" id="L1212">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Suppresses the 'zTXt' chunk from being output.
     */
<span class="nc" id="L1217">    public void unsetCompressedText() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1432);</span>
<span class="nc" id="L1218">        __CLR4_5_2u5u5m68iyfte.R.inc(1433);zText = null;</span>
<span class="nc" id="L1219">        __CLR4_5_2u5u5m68iyfte.R.inc(1434);zTextSet = false;</span>
<span class="nc" id="L1220">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns true if a 'zTXT' chunk will be output.
     */
<span class="fc" id="L1225">    public boolean isCompressedTextSet() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1435);</span>
<span class="fc" id="L1226">        __CLR4_5_2u5u5m68iyfte.R.inc(1436);return zTextSet;</span>
<span class="fc" id="L1227">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    // Other chunk types

<span class="fc" id="L1231">    List chunkType = new ArrayList();</span>
<span class="fc" id="L1232">    List chunkData = new ArrayList();</span>

    /**
     * Adds a private chunk, in binary form, to the list of chunks to
     * be stored with this image.
     *
     * @param type a 4-character String giving the chunk type name.
     * @param data an array of &lt;code&gt;byte&lt;/code&gt;s containing the
     *        chunk data.
     */
<span class="nc" id="L1242">    public synchronized void addPrivateChunk(String type, byte[] data) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1437);</span>
<span class="nc" id="L1243">        __CLR4_5_2u5u5m68iyfte.R.inc(1438);chunkType.add(type);</span>
<span class="nc" id="L1244">        __CLR4_5_2u5u5m68iyfte.R.inc(1439);chunkData.add(data.clone());</span>
<span class="nc" id="L1245">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns the number of private chunks to be written to the
     * output file.
     */
<span class="fc" id="L1251">    public synchronized int getNumPrivateChunks() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1440);</span>
<span class="fc" id="L1252">        __CLR4_5_2u5u5m68iyfte.R.inc(1441);return chunkType.size();</span>
<span class="fc" id="L1253">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns the type of the private chunk at a given index, as a
     * 4-character &lt;code&gt;String&lt;/code&gt;.  The index must be smaller
     * than the return value of &lt;code&gt;getNumPrivateChunks&lt;/code&gt;.
     */
<span class="nc" id="L1260">    public synchronized String getPrivateChunkType(int index) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1442);</span>
<span class="nc" id="L1261">        __CLR4_5_2u5u5m68iyfte.R.inc(1443);return (String)chunkType.get(index);</span>
<span class="nc" id="L1262">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Returns the data associated of the private chunk at a given
     * index, as an array of &lt;code&gt;byte&lt;/code&gt;s.  The index must be
     * smaller than the return value of
     * &lt;code&gt;getNumPrivateChunks&lt;/code&gt;.
     */
<span class="nc" id="L1270">    public synchronized byte[] getPrivateChunkData(int index) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1444);</span>
<span class="nc" id="L1271">        __CLR4_5_2u5u5m68iyfte.R.inc(1445);return (byte[])chunkData.get(index);</span>
<span class="nc" id="L1272">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Remove all private chunks associated with this parameter instance
     * whose 'safe-to-copy' bit is not set.  This may be advisable when
     * transcoding PNG images.
     */
<span class="nc" id="L1279">    public synchronized void removeUnsafeToCopyPrivateChunks() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1446);</span>
<span class="nc" id="L1280">        __CLR4_5_2u5u5m68iyfte.R.inc(1447);List newChunkType = new ArrayList();</span>
<span class="nc" id="L1281">        __CLR4_5_2u5u5m68iyfte.R.inc(1448);List newChunkData = new ArrayList();</span>

<span class="nc" id="L1283">        __CLR4_5_2u5u5m68iyfte.R.inc(1449);int len = getNumPrivateChunks();</span>
<span class="nc bnc" id="L1284" title="All 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1450);for (int i = 0; (((i &lt; len)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1451)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1452)==0&amp;false)); i++) {{</span>
<span class="nc" id="L1285">            __CLR4_5_2u5u5m68iyfte.R.inc(1453);String type = getPrivateChunkType(i);</span>
<span class="nc" id="L1286">            __CLR4_5_2u5u5m68iyfte.R.inc(1454);char lastChar = type.charAt(3);</span>
<span class="nc bnc" id="L1287" title="All 12 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1455);if ((((lastChar &gt;= 'a' &amp;&amp; lastChar &lt;= 'z')&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1456)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1457)==0&amp;false))) {{</span>
<span class="nc" id="L1288">                __CLR4_5_2u5u5m68iyfte.R.inc(1458);newChunkType.add(type);</span>
<span class="nc" id="L1289">                __CLR4_5_2u5u5m68iyfte.R.inc(1459);newChunkData.add(getPrivateChunkData(i));</span>
            }
        }}

<span class="nc" id="L1293">        }__CLR4_5_2u5u5m68iyfte.R.inc(1460);chunkType = newChunkType;</span>
<span class="nc" id="L1294">        __CLR4_5_2u5u5m68iyfte.R.inc(1461);chunkData = newChunkData;</span>
<span class="nc" id="L1295">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Remove all private chunks associated with this parameter instance.
     */
<span class="nc" id="L1300">    public synchronized void removeAllPrivateChunks() {try{__CLR4_5_2u5u5m68iyfte.R.inc(1462);</span>
<span class="nc" id="L1301">        __CLR4_5_2u5u5m68iyfte.R.inc(1463);chunkType = new ArrayList();</span>
<span class="nc" id="L1302">        __CLR4_5_2u5u5m68iyfte.R.inc(1464);chunkData = new ArrayList();</span>
<span class="nc" id="L1303">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * An abs() function for use by the Paeth predictor.
     */
<span class="fc" id="L1308">    private static int abs(int x) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1465);</span>
<span class="pc bpc" id="L1309" title="4 of 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1466);return ((((x &lt; 0) )&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1467)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1468)==0&amp;false))? -x : x;</span>
<span class="fc" id="L1310">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * The Paeth predictor routine used in PNG encoding.  This routine
     * is included as a convenience to subclasses that override the
     * &lt;code&gt;filterRow&lt;/code&gt; method.
     */
<span class="fc" id="L1317">    public static int paethPredictor(int a, int b, int c) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1469);</span>
<span class="fc" id="L1318">        __CLR4_5_2u5u5m68iyfte.R.inc(1470);int p = a + b - c;</span>
<span class="fc" id="L1319">        __CLR4_5_2u5u5m68iyfte.R.inc(1471);int pa = abs(p - a);</span>
<span class="fc" id="L1320">        __CLR4_5_2u5u5m68iyfte.R.inc(1472);int pb = abs(p - b);</span>
<span class="fc" id="L1321">        __CLR4_5_2u5u5m68iyfte.R.inc(1473);int pc = abs(p - c);</span>

<span class="pc bpc" id="L1323" title="8 of 12 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1474);if (((((pa &lt;= pb) &amp;&amp; (pa &lt;= pc))&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1475)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1476)==0&amp;false))) {{</span>
<span class="fc" id="L1324">            __CLR4_5_2u5u5m68iyfte.R.inc(1477);return a;</span>
<span class="nc bnc" id="L1325" title="All 10 branches missed.">        } }else {__CLR4_5_2u5u5m68iyfte.R.inc(1478);if ((((pb &lt;= pc)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1479)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1480)==0&amp;false))) {{</span>
<span class="nc" id="L1326">            __CLR4_5_2u5u5m68iyfte.R.inc(1481);return b;</span>
        } }else {{
<span class="nc" id="L1328">            __CLR4_5_2u5u5m68iyfte.R.inc(1482);return c;</span>
        }
<span class="fc" id="L1330">    }}}finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>

    /**
     * Performs filtering on a row of an image.  This method may be
     * overridden in order to provide a custom algorithm for choosing
     * the filter type for a given row.
     *
     * &lt;p&gt; The method is supplied with the current and previous rows
     * of the image.  For the first row of the image, or of an
     * interlacing pass, the previous row array will be filled with
     * zeros as required by the PNG specification.
     *
     * &lt;p&gt; The method is also supplied with five scratch arrays.
     * These arrays may be used within the method for any purpose.
     * At method exit, the array at the index given by the return
     * value of the method should contain the filtered data.  The
     * return value will also be used as the filter type.
     *
     * &lt;p&gt; The default implementation of the method performs a trial
     * encoding with each of the filter types, and computes the sum of
     * absolute values of the differences between the raw bytes of the
     * current row and the predicted values.  The index of the filter
     * producing the smallest result is returned.
     *
     * &lt;p&gt; As an example, to perform only 'sub' filtering, this method
     * could be implemented (non-optimally) as follows:
     *
     * &lt;pre&gt;
     * for (int i = bytesPerPixel; i &amp;lt; bytesPerRow + bytesPerPixel; i++) {
     *     int curr = currRow[i] &amp;amp; 0xff;
     *     int left = currRow[i - bytesPerPixel] &amp;amp; 0xff;
     *     scratchRow[PNG_FILTER_SUB][i] = (byte)(curr - left);
     * }
     * return PNG_FILTER_SUB;
     * &lt;/pre&gt;
     *
     * @param currRow The current row as an array of &lt;code&gt;byte&lt;/code&gt;s
     *        of length at least &lt;code&gt;bytesPerRow + bytesPerPixel&lt;/code&gt;.
     *        The pixel data starts at index &lt;code&gt;bytesPerPixel&lt;/code&gt;;
     *        the initial &lt;code&gt;bytesPerPixel&lt;/code&gt; bytes are zero.
     * @param prevRow The current row as an array of &lt;code&gt;byte&lt;/code&gt;s
     *        The pixel data starts at index &lt;code&gt;bytesPerPixel&lt;/code&gt;;
     *        the initial &lt;code&gt;bytesPerPixel&lt;/code&gt; bytes are zero.
     * @param scratchRows An array of 5 &lt;code&gt;byte&lt;/code&gt; arrays of
     *        length at least &lt;code&gt;bytesPerRow +
     *        bytesPerPixel&lt;/code&gt;, useable to hold temporary results.
     *        The filtered row will be returned as one of the entries
     *        of this array.  The returned filtered data should start
     *        at index &lt;code&gt;bytesPerPixel&lt;/code&gt;; The initial
     *        &lt;code&gt;bytesPerPixel&lt;/code&gt; bytes are not used.
     * @param bytesPerRow The number of bytes in the image row.
     *        This value will always be greater than 0.
     * @param bytesPerPixel The number of bytes representing a single
     *        pixel, rounded up to an integer.  This is the 'bpp' parameter
     *        described in the PNG specification.
     *
     * @return The filter type to be used.  The entry of
     *         &lt;code&gt;scratchRows[]&lt;/code&gt; at this index holds the
     *         filtered data.  */
    public int filterRow(byte[] currRow,
                         byte[] prevRow,
                         byte[][] scratchRows,
                         int bytesPerRow,
<span class="fc" id="L1393">                         int bytesPerPixel) {try{__CLR4_5_2u5u5m68iyfte.R.inc(1483);</span>

<span class="fc" id="L1395">        __CLR4_5_2u5u5m68iyfte.R.inc(1484);int [] badness = {0, 0, 0, 0, 0};</span>
<span class="fc" id="L1396">        __CLR4_5_2u5u5m68iyfte.R.inc(1485);int curr;</span>
<span class="fc" id="L1397">        __CLR4_5_2u5u5m68iyfte.R.inc(1486);int left;</span>
<span class="fc" id="L1398">        __CLR4_5_2u5u5m68iyfte.R.inc(1487);int up;</span>
<span class="fc" id="L1399">        __CLR4_5_2u5u5m68iyfte.R.inc(1488);int upleft;</span>
<span class="fc" id="L1400">        __CLR4_5_2u5u5m68iyfte.R.inc(1489);int diff;</span>
<span class="fc" id="L1401">        __CLR4_5_2u5u5m68iyfte.R.inc(1490);int pa;</span>
<span class="fc" id="L1402">        __CLR4_5_2u5u5m68iyfte.R.inc(1491);int pb;</span>
<span class="fc" id="L1403">        __CLR4_5_2u5u5m68iyfte.R.inc(1492);int pc;</span>
<span class="pc bpc" id="L1404" title="4 of 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1493);for (int i = bytesPerPixel; (((i &lt; bytesPerRow + bytesPerPixel)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1494)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1495)==0&amp;false)); i++) {{</span>
<span class="fc" id="L1405">            __CLR4_5_2u5u5m68iyfte.R.inc(1496);curr   = currRow[i] &amp; 0xff;</span>
<span class="fc" id="L1406">            __CLR4_5_2u5u5m68iyfte.R.inc(1497);left   = currRow[i - bytesPerPixel] &amp; 0xff;</span>
<span class="fc" id="L1407">            __CLR4_5_2u5u5m68iyfte.R.inc(1498);up     = prevRow[i] &amp; 0xff;</span>
<span class="fc" id="L1408">            __CLR4_5_2u5u5m68iyfte.R.inc(1499);upleft = prevRow[i - bytesPerPixel] &amp; 0xff;</span>

            // no filter
<span class="fc" id="L1411">            __CLR4_5_2u5u5m68iyfte.R.inc(1500);badness[0] += curr;</span>

            // sub filter
<span class="fc" id="L1414">            __CLR4_5_2u5u5m68iyfte.R.inc(1501);diff = curr - left;</span>
<span class="fc" id="L1415">            __CLR4_5_2u5u5m68iyfte.R.inc(1502);scratchRows[1][i]  = (byte)diff;</span>
<span class="pc bpc" id="L1416" title="4 of 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1503);badness    [1]    +=   ((((diff &gt; 0) )&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1504)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1505)==0&amp;false))? diff : -diff;</span>

            // up filter
<span class="fc" id="L1419">            __CLR4_5_2u5u5m68iyfte.R.inc(1506);diff = curr - up;</span>
<span class="fc" id="L1420">            __CLR4_5_2u5u5m68iyfte.R.inc(1507);scratchRows[2][i]  = (byte)diff;</span>
<span class="pc bpc" id="L1421" title="7 of 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1508);badness    [2]    +=   ((((diff &gt;= 0) )&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1509)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1510)==0&amp;false))? diff : -diff;</span>

            // average filter
<span class="fc" id="L1424">            __CLR4_5_2u5u5m68iyfte.R.inc(1511);diff = curr - ((left + up) &gt;&gt; 1);</span>
<span class="fc" id="L1425">            __CLR4_5_2u5u5m68iyfte.R.inc(1512);scratchRows[3][i]  = (byte)diff;</span>
<span class="pc bpc" id="L1426" title="7 of 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1513);badness    [3]    +=   ((((diff &gt;= 0) )&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1514)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1515)==0&amp;false))? diff : -diff;</span>

            // paeth filter

            // Original code much simplier but doesn't take full
            // advantage of relationship between pa/b/c and
            // information gleaned in abs operations.
            /// pa = up  -upleft;
            /// pb = left-upleft;
            /// pc = pa+pb;
            /// pa = abs(pa);
            /// pb = abs(pb);
            /// pc = abs(pc);
            /// if ((pa &lt;= pb) &amp;&amp; (pa &lt;= pc))
            ///   diff = curr-left;
            /// else if (pb &lt;= pc)
            ///   diff = curr-up;
            /// else
            ///   diff = curr-upleft;

<span class="fc" id="L1446">            __CLR4_5_2u5u5m68iyfte.R.inc(1516);pa = up  - upleft;</span>
<span class="fc" id="L1447">            __CLR4_5_2u5u5m68iyfte.R.inc(1517);pb = left - upleft;</span>
<span class="pc bpc" id="L1448" title="7 of 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1518);if ((((pa &lt; 0)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1519)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1520)==0&amp;false))) {{</span>
<span class="nc bnc" id="L1449" title="All 10 branches missed.">              __CLR4_5_2u5u5m68iyfte.R.inc(1521);if ((((pb &lt; 0)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1522)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1523)==0&amp;false))) {{</span>
                // both pa &amp; pb neg so pc is always greater than or
                // equal to pa or pb;
<span class="nc bnc" id="L1452" title="All 10 branches missed.">                __CLR4_5_2u5u5m68iyfte.R.inc(1524);if ((((pa &gt;= pb)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1525)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1526)==0&amp;false))) {{ // since pa &amp; pb neg check sense is reversed.</span>
<span class="nc" id="L1453">                  __CLR4_5_2u5u5m68iyfte.R.inc(1527);diff = curr - left;</span>
                } }else {{
<span class="nc" id="L1455">                  __CLR4_5_2u5u5m68iyfte.R.inc(1528);diff = curr - up;</span>
                }
              }} }else {{
                // pa neg pb pos so we must compute pc...
<span class="nc" id="L1459">                __CLR4_5_2u5u5m68iyfte.R.inc(1529);pc = pa + pb;</span>
<span class="nc" id="L1460">                __CLR4_5_2u5u5m68iyfte.R.inc(1530);pa = -pa;</span>
<span class="nc bnc" id="L1461" title="All 10 branches missed.">                __CLR4_5_2u5u5m68iyfte.R.inc(1531);if ((((pa &lt;= pb)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1532)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1533)==0&amp;false))) {{ // pc is positive and less than pb</span>
<span class="nc bnc" id="L1462" title="All 10 branches missed.">                  __CLR4_5_2u5u5m68iyfte.R.inc(1534);if ((((pa &lt;= pc)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1535)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1536)==0&amp;false))) {{</span>
<span class="nc" id="L1463">                    __CLR4_5_2u5u5m68iyfte.R.inc(1537);diff = curr - left;</span>
                  } }else {{
<span class="nc" id="L1465">                    __CLR4_5_2u5u5m68iyfte.R.inc(1538);diff = curr - upleft;</span>
                  }
                }} }else {{
                  // pc is negative and less than or equal to pa,
                  // but since pa is greater than pb this isn't an issue...
<span class="nc bnc" id="L1470" title="All 10 branches missed.">                  __CLR4_5_2u5u5m68iyfte.R.inc(1539);if ((((pb &lt;= -pc)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1540)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1541)==0&amp;false))) {{</span>
<span class="nc" id="L1471">                    __CLR4_5_2u5u5m68iyfte.R.inc(1542);diff = curr - up;</span>
                  } }else {{
<span class="nc" id="L1473">                    __CLR4_5_2u5u5m68iyfte.R.inc(1543);diff = curr - upleft;</span>
                  }
                }}
              }}
            }} }else {{
<span class="pc bpc" id="L1478" title="7 of 10 branches missed.">              __CLR4_5_2u5u5m68iyfte.R.inc(1544);if ((((pb &lt; 0)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1545)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1546)==0&amp;false))) {{</span>
<span class="nc" id="L1479">                __CLR4_5_2u5u5m68iyfte.R.inc(1547);pb = -pb; // make it positive...</span>
<span class="nc bnc" id="L1480" title="All 10 branches missed.">                __CLR4_5_2u5u5m68iyfte.R.inc(1548);if ((((pa &lt;= pb)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1549)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1550)==0&amp;false))) {{</span>
                  // pc would be negative and less than or equal to pb
<span class="nc" id="L1482">                  __CLR4_5_2u5u5m68iyfte.R.inc(1551);pc = pb - pa;</span>
<span class="nc bnc" id="L1483" title="All 10 branches missed.">                  __CLR4_5_2u5u5m68iyfte.R.inc(1552);if ((((pa &lt;= pc)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1553)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1554)==0&amp;false))) {{</span>
<span class="nc" id="L1484">                    __CLR4_5_2u5u5m68iyfte.R.inc(1555);diff = curr - left;</span>
<span class="nc bnc" id="L1485" title="All 10 branches missed.">                  } }else {__CLR4_5_2u5u5m68iyfte.R.inc(1556);if ((((pb == pc)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1557)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1558)==0&amp;false))) {{</span>
                    // if pa is zero then pc==pb otherwise
                    // pc must be less than pb.
<span class="nc" id="L1488">                    __CLR4_5_2u5u5m68iyfte.R.inc(1559);diff = curr - up;</span>
                  } }else {{
<span class="nc" id="L1490">                    __CLR4_5_2u5u5m68iyfte.R.inc(1560);diff = curr - upleft;</span>
                  }
                }}} }else {{
                  // pc would be positive and less than pa.
<span class="nc" id="L1494">                  __CLR4_5_2u5u5m68iyfte.R.inc(1561);pc = pa - pb;</span>
<span class="nc bnc" id="L1495" title="All 10 branches missed.">                  __CLR4_5_2u5u5m68iyfte.R.inc(1562);if ((((pb &lt;= pc)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1563)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1564)==0&amp;false))) {{</span>
<span class="nc" id="L1496">                    __CLR4_5_2u5u5m68iyfte.R.inc(1565);diff = curr - up;</span>
                  } }else {{
<span class="nc" id="L1498">                    __CLR4_5_2u5u5m68iyfte.R.inc(1566);diff = curr - upleft;</span>
                  }
                }}
              }} }else {{
                // both pos so pa+pb is always greater than pa/pb
<span class="pc bpc" id="L1503" title="4 of 10 branches missed.">                __CLR4_5_2u5u5m68iyfte.R.inc(1567);if ((((pa &lt;= pb)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1568)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1569)==0&amp;false))) {{</span>
<span class="fc" id="L1504">                  __CLR4_5_2u5u5m68iyfte.R.inc(1570);diff = curr - left;</span>
                } }else {{
<span class="fc" id="L1506">                  __CLR4_5_2u5u5m68iyfte.R.inc(1571);diff = curr - up;</span>
                }
              }}
            }}
<span class="fc" id="L1510">            }__CLR4_5_2u5u5m68iyfte.R.inc(1572);scratchRows[4][i]  = (byte)diff;</span>
<span class="pc bpc" id="L1511" title="7 of 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1573);badness    [4]    +=   ((((diff &gt;= 0) )&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1574)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1575)==0&amp;false))? diff : -diff;</span>
        }
<span class="fc" id="L1513">        }__CLR4_5_2u5u5m68iyfte.R.inc(1576);int filterType = 0;</span>
<span class="fc" id="L1514">        __CLR4_5_2u5u5m68iyfte.R.inc(1577);int minBadness = badness[0];</span>

<span class="pc bpc" id="L1516" title="4 of 10 branches missed.">        __CLR4_5_2u5u5m68iyfte.R.inc(1578);for (int i = 1; (((i &lt; 5)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1579)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1580)==0&amp;false)); i++) {{</span>
<span class="pc bpc" id="L1517" title="4 of 10 branches missed.">            __CLR4_5_2u5u5m68iyfte.R.inc(1581);if ((((badness[i] &lt; minBadness)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1582)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1583)==0&amp;false))) {{</span>
<span class="fc" id="L1518">                __CLR4_5_2u5u5m68iyfte.R.inc(1584);minBadness = badness[i];</span>
<span class="fc" id="L1519">                __CLR4_5_2u5u5m68iyfte.R.inc(1585);filterType = i;</span>
            }
        }}

<span class="pc bpc" id="L1523" title="7 of 10 branches missed.">        }__CLR4_5_2u5u5m68iyfte.R.inc(1586);if ((((filterType == 0)&amp;&amp;(__CLR4_5_2u5u5m68iyfte.R.iget(1587)!=0|true))||(__CLR4_5_2u5u5m68iyfte.R.iget(1588)==0&amp;false))) {{</span>
<span class="nc" id="L1524">            __CLR4_5_2u5u5m68iyfte.R.inc(1589);System.arraycopy(currRow, bytesPerPixel,</span>
                             scratchRows[0], bytesPerPixel,
                             bytesPerRow);
        }

<span class="fc" id="L1529">        }__CLR4_5_2u5u5m68iyfte.R.inc(1590);return filterType;</span>
<span class="fc" id="L1530">    }finally{__CLR4_5_2u5u5m68iyfte.R.flushNeeded();}}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>