<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SeekableStream.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">org.apache.xmlgraphics:xmlgraphics-commons</a> &gt; <a href="index.source.html" class="el_package">org.apache.xmlgraphics.image.codec.util</a> &gt; <span class="el_source">SeekableStream.java</span></div><h1>SeekableStream.java</h1><pre class="source lang-java linenums">/* $$ This file has been instrumented by Clover 4.5.2#20240131180750 $$ *//*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* $Id: SeekableStream.java 1732018 2016-02-24 04:51:06Z gadams $ */

package org.apache.xmlgraphics.image.codec.util;

import java.io.DataInput;
import java.io.DataInputStream;
import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;

/**
 * An abstract subclass of &lt;code&gt;java.io.InputStream&lt;/code&gt; that allows seeking
 * within the input, similar to the &lt;code&gt;RandomAccessFile&lt;/code&gt; class.
 * Additionally, the &lt;code&gt;DataInput&lt;/code&gt; interface is supported and extended
 * to include support for little-endian representations of fundamental data
 * types.
 *
 * &lt;p&gt; In addition to the familiar methods from &lt;code&gt;InputStream&lt;/code&gt;, the
 * methods &lt;code&gt;getFilePointer()&lt;/code&gt;, &lt;code&gt;seek()&lt;/code&gt;, are defined as in
 * the &lt;code&gt;RandomAccessFile&lt;/code&gt; class.  The &lt;code&gt;canSeekBackwards()&lt;/code&gt;
 * method will return &lt;code&gt;true&lt;/code&gt; if it is permissible to seek to a
 * position earlier in the stream than the current value of
 * &lt;code&gt;getFilePointer()&lt;/code&gt;.  Some subclasses of
 * &lt;code&gt;SeekableStream&lt;/code&gt; guarantee the ability to seek backwards while
 * others may not offer this feature in the interest of providing greater
 * efficiency for those users who do not require it.
 *
 * &lt;p&gt; The &lt;code&gt;DataInput&lt;/code&gt; interface is supported as well.  This included
 * the &lt;code&gt;skipBytes()&lt;/code&gt; and &lt;code&gt;readFully()&lt;/code&gt; methods and a
 * variety of &lt;code&gt;read&lt;/code&gt; methods for various data types.
 *
 * &lt;p&gt; Three classes are provided for the purpose of adapting a standard
 * &lt;code&gt;InputStream&lt;/code&gt; to the &lt;code&gt;SeekableStream&lt;/code&gt; interface.
 * &lt;code&gt;ForwardSeekableStream&lt;/code&gt; does not allows seeking backwards, but is
 * inexpensive to use.  &lt;code&gt;FileCacheSeekableStream&lt;/code&gt; maintains a copy of
 * all of the data read from the input in a temporary file; this file will be
 * discarded automatically when the &lt;code&gt;FileSeekableStream&lt;/code&gt; is
 * finalized, or when the JVM exits normally.
 * &lt;code&gt;FileCacheSeekableStream&lt;/code&gt; is intended to be reasonably efficient
 * apart from the unavoidable use of disk space.  In circumstances where the
 * creation of a temporary file is not possible,
 * &lt;code&gt;MemoryCacheSeekableStream&lt;/code&gt; may be used.
 * &lt;code&gt;MemoryCacheSeekableStream&lt;/code&gt; creates a potentially large in-memory
 * buffer to store the stream data and so should be avoided when possible.
 *
 * &lt;p&gt; The &lt;code&gt;FileSeekableStream&lt;/code&gt; class wraps a &lt;code&gt;File&lt;/code&gt; or
 * &lt;code&gt;RandomAccessFile&lt;/code&gt;. It forwards requests to the real underlying
 * file.  It performs a limited amount of caching in order to avoid excessive
 * I/O costs.
 *
 * &lt;p&gt; The &lt;code&gt;SegmentedSeekableStream&lt;/code&gt; class performs a different sort
 * of function.  It creates a &lt;code&gt;SeekableStream&lt;/code&gt; from another
 * &lt;code&gt;SeekableStream&lt;/code&gt; by selecting a series of portions or &quot;segments&quot;.
 * Each segment starts at a specified location within the source
 * &lt;code&gt;SeekableStream&lt;/code&gt; and extends for a specified number of bytes.  The
 * &lt;code&gt;StreamSegmentMapper&lt;/code&gt; interface and &lt;code&gt;StreamSegment&lt;/code&gt;
 * class may be used to compute the segment positions dynamically.
 *
 * &lt;p&gt; A convenience methods, &lt;code&gt;wrapInputStream&lt;/code&gt; is provided to
 * construct a suitable &lt;code&gt;SeekableStream&lt;/code&gt; instance whose data is
 * supplied by a given &lt;code&gt;InputStream&lt;/code&gt;.  The caller, by means of the
 * &lt;code&gt;canSeekBackwards&lt;/code&gt; parameter, determines whether support for
 * seeking backwards is required.
 *
 */
<span class="pc bpc" id="L83" title="3 of 4 branches missed.">@java.lang.SuppressWarnings({&quot;fallthrough&quot;}) public abstract class SeekableStream extends InputStream implements DataInput {public static class __CLR4_5_26sa6sam6lb4zlb{public static com_atlassian_clover.CoverageRecorder R;public static com_atlassian_clover.CloverProfile[] profiles = { };@java.lang.SuppressWarnings(&quot;unchecked&quot;) public static &lt;I, T extends I&gt; I lambdaInc(final int i,final T l,final int si){java.lang.reflect.InvocationHandler h=new java.lang.reflect.InvocationHandler(){public java.lang.Object invoke(java.lang.Object p,java.lang.reflect.Method m,java.lang.Object[] a) throws Throwable{R.inc(i);R.inc(si);try{return m.invoke(l,a);}catch(java.lang.reflect.InvocationTargetException e){throw e.getCause()!=null?e.getCause():new RuntimeException(&quot;Clover failed to invoke instrumented lambda&quot;,e);}}};return (I)java.lang.reflect.Proxy.newProxyInstance(l.getClass().getClassLoader(),l.getClass().getInterfaces(),h);}public static &lt;T&gt; T caseInc(int i,java.util.function.Supplier&lt;T&gt; s){R.inc(i);return s.get();}public static void caseInc(int i,Runnable r){R.inc(i);r.run();}static{com_atlassian_clover.CoverageRecorder _R=null;try{com_atlassian_clover.CloverVersionInfo.An_old_version_of_clover_is_on_your_compilation_classpath___Please_remove___Required_version_is___4_5_2();if(20240131180750L!=com_atlassian_clover.CloverVersionInfo.getBuildStamp()){com_atlassian_clover.Clover.l(&quot;[CLOVER] WARNING: The Clover version used in instrumentation shall match the runtime version.&quot;);com_atlassian_clover.Clover.l(&quot;[CLOVER] WARNING: Instr=4.5.2#20240131180750,Runtime=&quot;+com_atlassian_clover.CloverVersionInfo.getReleaseNum()+&quot;#&quot;+com_atlassian_clover.CloverVersionInfo.getBuildStamp());}R=com_atlassian_clover.Clover.getNullRecorder();_R=com_atlassian_clover.Clover.getNullRecorder();_R=com_atlassian_clover.Clover.getRecorder(&quot;\u002f\u0063\u006f\u0064\u0065\u002f\u0063\u006f\u006e\u0063\u006f\u0072\u0064\u0069\u0061\u002f\u0053\u004f\u0045\u004e\u002d\u0033\u0034\u0035\u002d\u0054\u0075\u0074\u006f\u0072\u0069\u0061\u006c\u0073\u002f\u0074\u0075\u0074\u006f\u0072\u0069\u0061\u006c\u0031\u002f\u0050\u0061\u0072\u0074\u002d\u0042\u002f\u0078\u006d\u006c\u0067\u0072\u0061\u0070\u0068\u0069\u0063\u0073\u002d\u0063\u006f\u006d\u006d\u006f\u006e\u0073\u002d\u0032\u002e\u0038\u002f\u0074\u0061\u0072\u0067\u0065\u0074\u002f\u0063\u006c\u006f\u0076\u0065\u0072\u002f\u0063\u006c\u006f\u0076\u0065\u0072\u002e\u0064\u0062&quot;,1738360798893L,8589935092L,8990,profiles,new java.lang.String[]{&quot;clover.distributed.coverage&quot;,null});}catch(java.lang.SecurityException e){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised because it has insufficient security privileges. Please consult the Clover documentation on the security policy file changes required. (&quot;+e.getClass()+&quot;:&quot;+e.getMessage()+&quot;)&quot;);}catch(java.lang.NoClassDefFoundError e){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised. Are you sure you have Clover in the runtime classpath? (&quot;+e.getClass()+&quot;:&quot;+e.getMessage()+&quot;)&quot;);}catch(java.lang.Throwable t){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised because of an unexpected error. (&quot;+t.getClass()+&quot;:&quot;+t.getMessage()+&quot;)&quot;);}R=_R;}}public static final com_atlassian_clover.TestNameSniffer __CLR4_5_2_TEST_NAME_SNIFFER=com_atlassian_clover.TestNameSniffer.NULL_INSTANCE;</span>

    /**
     * Returns a &lt;code&gt;SeekableStream&lt;/code&gt; that will read from a
     * given &lt;code&gt;InputStream&lt;/code&gt;, optionally including support
     * for seeking backwards.  This is a convenience method that
     * avoids the need to instantiate specific subclasses of
     * &lt;code&gt;SeekableStream&lt;/code&gt; depending on the current security
     * model.
     *
     * @param is An &lt;code&gt;InputStream&lt;/code&gt;.
     * @param canSeekBackwards &lt;code&gt;true&lt;/code&gt; if the ability to seek
     *        backwards in the output is required.
     * @return An instance of &lt;code&gt;SeekableStream&lt;/code&gt;.
     */
    public static SeekableStream wrapInputStream(InputStream is,
<span class="nc" id="L99">                                                 boolean canSeekBackwards) {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8794);</span>
<span class="nc" id="L100">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8795);SeekableStream stream = null;</span>

<span class="nc bnc" id="L102" title="All 10 branches missed.">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8796);if ((((canSeekBackwards)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8797)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8798)==0&amp;false))) {{</span>
<span class="nc" id="L103">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8799);try {</span>
<span class="nc" id="L104">                __CLR4_5_26sa6sam6lb4zlb.R.inc(8800);stream = new FileCacheSeekableStream(is);</span>
<span class="nc" id="L105">            } catch (Exception e) {</span>
<span class="nc" id="L106">                __CLR4_5_26sa6sam6lb4zlb.R.inc(8801);stream = new MemoryCacheSeekableStream(is);</span>
<span class="nc" id="L107">            }</span>
        } }else {{
<span class="nc" id="L109">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8802);stream = new ForwardSeekableStream(is);</span>
        }
<span class="nc" id="L111">        }__CLR4_5_26sa6sam6lb4zlb.R.inc(8803);return stream;</span>
<span class="nc" id="L112">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    // Methods from InputStream

    /**
     * Reads the next byte of data from the input stream. The value byte is
     * returned as an &lt;code&gt;int&lt;/code&gt; in the range &lt;code&gt;0&lt;/code&gt; to
     * &lt;code&gt;255&lt;/code&gt;. If no byte is available because the end of the stream
     * has been reached, the value &lt;code&gt;-1&lt;/code&gt; is returned. This method
     * blocks until input data is available, the end of the stream is detected,
     * or an exception is thrown.
     *
     * &lt;p&gt; A subclass must provide an implementation of this method.
     *
     * @return     the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
     *             stream is reached.
     * @exception  IOException  if an I/O error occurs.
     */
    public abstract int read() throws IOException;

    /**
     * Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from the input stream into
     * an array of bytes.  An attempt is made to read as many as
     * &lt;code&gt;len&lt;/code&gt; bytes, but a smaller number may be read, possibly
     * zero. The number of bytes actually read is returned as an integer.
     *
     * &lt;p&gt; This method blocks until input data is available, end of stream is
     * detected, or an exception is thrown.
     *
     * &lt;p&gt; If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a
     * &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; If &lt;code&gt;off&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is negative, or
     * &lt;code&gt;off+len&lt;/code&gt; is greater than the length of the array
     * &lt;code&gt;b&lt;/code&gt;, then an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; is
     * thrown.
     *
     * &lt;p&gt; If &lt;code&gt;len&lt;/code&gt; is zero, then no bytes are read and
     * &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at
     * least one byte. If no byte is available because the stream is at end of
     * stream, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at least one
     * byte is read and stored into &lt;code&gt;b&lt;/code&gt;.
     *
     * &lt;p&gt; The first byte read is stored into element &lt;code&gt;b[off]&lt;/code&gt;, the
     * next one into &lt;code&gt;b[off+1]&lt;/code&gt;, and so on. The number of bytes read
     * is, at most, equal to &lt;code&gt;len&lt;/code&gt;. Let &lt;i&gt;k&lt;/i&gt; be the number of
     * bytes actually read; these bytes will be stored in elements
     * &lt;code&gt;b[off]&lt;/code&gt; through &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1]&lt;/code&gt;,
     * leaving elements &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; through
     * &lt;code&gt;b[off+len-1]&lt;/code&gt; unaffected.
     *
     * &lt;p&gt; In every case, elements &lt;code&gt;b[0]&lt;/code&gt; through
     * &lt;code&gt;b[off]&lt;/code&gt; and elements &lt;code&gt;b[off+len]&lt;/code&gt; through
     * &lt;code&gt;b[b.length-1]&lt;/code&gt; are unaffected.
     *
     * &lt;p&gt; If the first byte cannot be read for any reason other than end of
     * stream, then an &lt;code&gt;IOException&lt;/code&gt; is thrown. In particular, an
     * &lt;code&gt;IOException&lt;/code&gt; is thrown if the input stream has been closed.
     *
     * &lt;p&gt; A subclass must provide an implementation of this method.
     *
     * @param      b     the buffer into which the data is read.
     * @param      off   the start offset in array &lt;code&gt;b&lt;/code&gt;
     *                   at which the data is written.
     * @param      len   the maximum number of bytes to read.
     * @return     the total number of bytes read into the buffer, or
     *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
     *             the stream has been reached.
     * @exception  IOException  if an I/O error occurs.
     */
    public abstract int read(byte[] b, int off, int len) throws IOException;

    // Implemented in InputStream:
    //
    // public int read(byte[] b) throws IOException {
    // public long skip(long n) throws IOException
    // public int available) throws IOException
    // public void close() throws IOException;

    /** Marked position, shared by {@link ForwardSeekableStream} */
<span class="fc" id="L192">    protected long markPos = -1L;</span>

    /**
     * Marks the current file position for later return using
     * the &lt;code&gt;reset()&lt;/code&gt; method.
     */
<span class="fc" id="L198">    public synchronized void mark(int readLimit) {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8804);</span>
<span class="fc" id="L199">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8805);try {</span>
<span class="fc" id="L200">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8806);markPos = getFilePointer();</span>
<span class="nc" id="L201">        } catch (IOException e) {</span>
<span class="nc" id="L202">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8807);markPos = -1L;</span>
<span class="fc" id="L203">        }</span>
<span class="fc" id="L204">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Returns the file position to its position at the time of
     * the immediately previous call to the &lt;code&gt;mark()&lt;/code&gt;
     * method.
     */
<span class="fc" id="L211">    public synchronized void reset() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8808);</span>
<span class="pc bpc" id="L212" title="7 of 10 branches missed.">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8809);if ((((markPos != -1)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8810)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8811)==0&amp;false))) {{</span>
<span class="fc" id="L213">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8812);seek(markPos);</span>
        }
<span class="fc" id="L215">    }}finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if marking is supported.
     * Marking is automatically supported for &lt;code&gt;SeekableStream&lt;/code&gt;
     * subclasses that support seeking backeards.  Subclasses that do
     * not support seeking backwards but do support marking must override
     * this method.
     */
<span class="fc" id="L224">    public boolean markSupported() {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8813);</span>
<span class="fc" id="L225">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8814);return canSeekBackwards();</span>
<span class="fc" id="L226">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this object supports calls to
     * &lt;code&gt;seek(pos)&lt;/code&gt; with an offset &lt;code&gt;pos&lt;/code&gt; smaller
     * than the current offset, as returned by &lt;code&gt;getFilePointer&lt;/code&gt;.
     */
<span class="nc" id="L233">    public boolean canSeekBackwards() {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8815);</span>
<span class="nc" id="L234">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8816);return false;</span>
<span class="nc" id="L235">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Returns the current offset in this stream.
     *
     * @return     the offset from the beginning of the stream, in bytes,
     *             at which the next read occurs.
     * @exception  IOException  if an I/O error occurs.
     */
    public abstract long getFilePointer() throws IOException;

    /**
     * Sets the offset, measured from the beginning of this
     * stream, at which the next read occurs.
     *
     * &lt;p&gt; If &lt;code&gt;canSeekBackwards()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;,
     * then setting &lt;code&gt;pos&lt;/code&gt; to an offset smaller than
     * the current value of &lt;code&gt;getFilePointer()&lt;/code&gt; will have
     * no effect.
     *
     * @param      pos   the offset position, measured in bytes from the
     *                   beginning of the stream, at which to set the stream
     *                   pointer.
     * @exception  IOException  if &lt;code&gt;pos&lt;/code&gt; is less than
     *                          &lt;code&gt;0&lt;/code&gt; or if an I/O error occurs.
     */
    public abstract void seek(long pos) throws IOException;

    // Methods from RandomAccessFile

    /**
     * Reads &lt;code&gt;b.length&lt;/code&gt; bytes from this stream into the byte
     * array, starting at the current stream pointer. This method reads
     * repeatedly from the stream until the requested number of bytes are
     * read. This method blocks until the requested number of bytes are
     * read, the end of the stream is detected, or an exception is thrown.
     *
     * @param      b   the buffer into which the data is read.
     * @exception  EOFException  if this stream reaches the end before reading
     *               all the bytes.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="fc" id="L277">    public final void readFully(byte[] b) throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8817);</span>
<span class="fc" id="L278">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8818);readFully(b, 0, b.length);</span>
<span class="fc" id="L279">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads exactly &lt;code&gt;len&lt;/code&gt; bytes from this stream into the byte
     * array, starting at the current stream pointer. This method reads
     * repeatedly from the stream until the requested number of bytes are
     * read. This method blocks until the requested number of bytes are
     * read, the end of the stream is detected, or an exception is thrown.
     *
     * @param      b     the buffer into which the data is read.
     * @param      off   the start offset of the data.
     * @param      len   the number of bytes to read.
     * @exception  EOFException  if this stream reaches the end before reading
     *               all the bytes.
     * @exception  IOException   if an I/O error occurs.
     */
    public final void readFully(byte[] b, int off, int len)
<span class="fc" id="L296">        throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8819);</span>
<span class="fc" id="L297">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8820);int n = 0;</span>
<span class="fc" id="L298">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8821);do {{</span>
<span class="fc" id="L299">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8822);int count = this.read(b, off + n, len - n);</span>
<span class="pc bpc" id="L300" title="7 of 10 branches missed.">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8823);if ((((count &lt; 0)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8824)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8825)==0&amp;false))) {{</span>
<span class="nc" id="L301">                __CLR4_5_26sa6sam6lb4zlb.R.inc(8826);throw new EOFException();</span>
            }
<span class="fc" id="L303">            }__CLR4_5_26sa6sam6lb4zlb.R.inc(8827);n += count;</span>
<span class="pc bpc" id="L304" title="7 of 10 branches missed.">        } }while ((((n &lt; len)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8828)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8829)==0&amp;false)));</span>
<span class="fc" id="L305">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    // Methods from DataInput, plus little-endian versions

    /**
     * Attempts to skip over &lt;code&gt;n&lt;/code&gt; bytes of input discarding the
     * skipped bytes.
     * &lt;p&gt;
     *
     * This method may skip over some smaller number of bytes, possibly zero.
     * This may result from any of a number of conditions; reaching end of
     * stream before &lt;code&gt;n&lt;/code&gt; bytes have been skipped is only one
     * possibility. This method never throws an &lt;code&gt;EOFException&lt;/code&gt;.
     * The actual number of bytes skipped is returned.  If &lt;code&gt;n&lt;/code&gt;
     * is negative, no bytes are skipped.
     *
     * @param      n   the number of bytes to be skipped.
     * @return     the actual number of bytes skipped.
     * @exception  IOException  if an I/O error occurs.
     */
<span class="nc" id="L325">    public int skipBytes(int n) throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8830);</span>
<span class="nc bnc" id="L326" title="All 10 branches missed.">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8831);if ((((n &lt;= 0)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8832)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8833)==0&amp;false))) {{</span>
<span class="nc" id="L327">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8834);return 0;</span>
        }
<span class="nc" id="L329">        }__CLR4_5_26sa6sam6lb4zlb.R.inc(8835);return (int)skip(n);</span>
<span class="nc" id="L330">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads a &lt;code&gt;boolean&lt;/code&gt; from this stream. This method reads a
     * single byte from the stream, starting at the current stream pointer.
     * A value of &lt;code&gt;0&lt;/code&gt; represents
     * &lt;code&gt;false&lt;/code&gt;. Any other value represents &lt;code&gt;true&lt;/code&gt;.
     * This method blocks until the byte is read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @return     the &lt;code&gt;boolean&lt;/code&gt; value read.
     * @exception  EOFException  if this stream has reached the end.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="nc" id="L344">    public final boolean readBoolean() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8836);</span>
<span class="nc" id="L345">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8837);int ch = this.read();</span>
<span class="nc bnc" id="L346" title="All 10 branches missed.">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8838);if ((((ch &lt; 0)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8839)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8840)==0&amp;false))) {{</span>
<span class="nc" id="L347">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8841);throw new EOFException();</span>
        }
<span class="nc bnc" id="L349" title="All 2 branches missed.">        }__CLR4_5_26sa6sam6lb4zlb.R.inc(8842);return (ch != 0);</span>
<span class="nc" id="L350">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads a signed eight-bit value from this stream. This method reads a
     * byte from the stream, starting from the current stream pointer.
     * If the byte read is &lt;code&gt;b&lt;/code&gt;, where
     * &lt;code&gt;0&amp;nbsp;&amp;lt;=&amp;nbsp;b&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code&gt;,
     * then the result is:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     (byte)(b)
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the byte is read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @return     the next byte of this stream as a signed eight-bit
     *             &lt;code&gt;byte&lt;/code&gt;.
     * @exception  EOFException  if this stream has reached the end.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="nc" id="L370">    public final byte readByte() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8843);</span>
<span class="nc" id="L371">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8844);int ch = this.read();</span>
<span class="nc bnc" id="L372" title="All 10 branches missed.">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8845);if ((((ch &lt; 0)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8846)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8847)==0&amp;false))) {{</span>
<span class="nc" id="L373">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8848);throw new EOFException();</span>
        }
<span class="nc" id="L375">        }__CLR4_5_26sa6sam6lb4zlb.R.inc(8849);return (byte)(ch);</span>
<span class="nc" id="L376">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads an unsigned eight-bit number from this stream. This method reads
     * a byte from this stream, starting at the current stream pointer,
     * and returns that byte.
     * &lt;p&gt;
     * This method blocks until the byte is read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @return     the next byte of this stream, interpreted as an unsigned
     *             eight-bit number.
     * @exception  EOFException  if this stream has reached the end.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="nc" id="L391">    public final int readUnsignedByte() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8850);</span>
<span class="nc" id="L392">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8851);int ch = this.read();</span>
<span class="nc bnc" id="L393" title="All 10 branches missed.">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8852);if ((((ch &lt; 0)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8853)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8854)==0&amp;false))) {{</span>
<span class="nc" id="L394">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8855);throw new EOFException();</span>
        }
<span class="nc" id="L396">        }__CLR4_5_26sa6sam6lb4zlb.R.inc(8856);return ch;</span>
<span class="nc" id="L397">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads a signed 16-bit number from this stream.
     * The method reads two
     * bytes from this stream, starting at the current stream pointer.
     * If the two bytes read, in order, are
     * &lt;code&gt;b1&lt;/code&gt; and &lt;code&gt;b2&lt;/code&gt;, where each of the two values is
     * between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;255&lt;/code&gt;, inclusive, then the
     * result is equal to:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     (short)((b1 &amp;lt;&amp;lt; 8) | b2)
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next two bytes of this stream, interpreted as a signed
     *             16-bit number.
     * @exception  EOFException  if this stream reaches the end before reading
     *               two bytes.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="nc" id="L420">    public final short readShort() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8857);</span>
<span class="nc" id="L421">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8858);int ch1 = this.read();</span>
<span class="nc" id="L422">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8859);int ch2 = this.read();</span>
<span class="nc bnc" id="L423" title="All 10 branches missed.">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8860);if (((((ch1 | ch2) &lt; 0)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8861)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8862)==0&amp;false))) {{</span>
<span class="nc" id="L424">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8863);throw new EOFException();</span>
        }
<span class="nc" id="L426">        }__CLR4_5_26sa6sam6lb4zlb.R.inc(8864);return (short)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));</span>
<span class="nc" id="L427">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads a signed 16-bit number from this stream in little-endian order.
     * The method reads two
     * bytes from this stream, starting at the current stream pointer.
     * If the two bytes read, in order, are
     * &lt;code&gt;b1&lt;/code&gt; and &lt;code&gt;b2&lt;/code&gt;, where each of the two values is
     * between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;255&lt;/code&gt;, inclusive, then the
     * result is equal to:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     (short)((b2 &amp;lt;&amp;lt; 8) | b1)
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next two bytes of this stream, interpreted as a signed
     *             16-bit number.
     * @exception  EOFException  if this stream reaches the end before reading
     *               two bytes.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="nc" id="L450">    public final short readShortLE() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8865);</span>
<span class="nc" id="L451">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8866);int ch1 = this.read();</span>
<span class="nc" id="L452">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8867);int ch2 = this.read();</span>
<span class="nc bnc" id="L453" title="All 10 branches missed.">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8868);if (((((ch1 | ch2) &lt; 0)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8869)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8870)==0&amp;false))) {{</span>
<span class="nc" id="L454">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8871);throw new EOFException();</span>
        }
<span class="nc" id="L456">        }__CLR4_5_26sa6sam6lb4zlb.R.inc(8872);return (short)((ch2 &lt;&lt; 8) + (ch1 &lt;&lt; 0));</span>
<span class="nc" id="L457">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads an unsigned 16-bit number from this stream. This method reads
     * two bytes from the stream, starting at the current stream pointer.
     * If the bytes read, in order, are
     * &lt;code&gt;b1&lt;/code&gt; and &lt;code&gt;b2&lt;/code&gt;, where
     * &lt;code&gt;0&amp;nbsp;&amp;lt;=&amp;nbsp;b1, b2&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code&gt;,
     * then the result is equal to:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     (b1 &amp;lt;&amp;lt; 8) | b2
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next two bytes of this stream, interpreted as an
     *             unsigned 16-bit integer.
     * @exception  EOFException  if this stream reaches the end before reading
     *             two bytes.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="fc" id="L479">    public final int readUnsignedShort() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8873);</span>
<span class="fc" id="L480">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8874);int ch1 = this.read();</span>
<span class="fc" id="L481">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8875);int ch2 = this.read();</span>
<span class="pc bpc" id="L482" title="7 of 10 branches missed.">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8876);if (((((ch1 | ch2) &lt; 0)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8877)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8878)==0&amp;false))) {{</span>
<span class="nc" id="L483">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8879);throw new EOFException();</span>
        }
<span class="fc" id="L485">        }__CLR4_5_26sa6sam6lb4zlb.R.inc(8880);return (ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0);</span>
<span class="fc" id="L486">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads an unsigned 16-bit number from this stream in little-endian order.
     * This method reads
     * two bytes from the stream, starting at the current stream pointer.
     * If the bytes read, in order, are
     * &lt;code&gt;b1&lt;/code&gt; and &lt;code&gt;b2&lt;/code&gt;, where
     * &lt;code&gt;0&amp;nbsp;&amp;lt;=&amp;nbsp;b1, b2&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code&gt;,
     * then the result is equal to:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     (b2 &amp;lt;&amp;lt; 8) | b1
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next two bytes of this stream, interpreted as an
     *             unsigned 16-bit integer.
     * @exception  EOFException  if this stream reaches the end before reading
     *               two bytes.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="fc" id="L509">    public final int readUnsignedShortLE() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8881);</span>
<span class="fc" id="L510">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8882);int ch1 = this.read();</span>
<span class="fc" id="L511">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8883);int ch2 = this.read();</span>
<span class="pc bpc" id="L512" title="7 of 10 branches missed.">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8884);if (((((ch1 | ch2) &lt; 0)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8885)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8886)==0&amp;false))) {{</span>
<span class="nc" id="L513">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8887);throw new EOFException();</span>
        }
<span class="fc" id="L515">        }__CLR4_5_26sa6sam6lb4zlb.R.inc(8888);return (ch2 &lt;&lt; 8) + (ch1 &lt;&lt; 0);</span>
<span class="fc" id="L516">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads a Unicode character from this stream. This method reads two
     * bytes from the stream, starting at the current stream pointer.
     * If the bytes read, in order, are
     * &lt;code&gt;b1&lt;/code&gt; and &lt;code&gt;b2&lt;/code&gt;, where
     * &lt;code&gt;0&amp;nbsp;&amp;lt;=&amp;nbsp;b1,&amp;nbsp;b2&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code&gt;,
     * then the result is equal to:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     (char)((b1 &amp;lt;&amp;lt; 8) | b2)
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next two bytes of this stream as a Unicode character.
     * @exception  EOFException  if this stream reaches the end before reading
     *               two bytes.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="nc" id="L537">    public final char readChar() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8889);</span>
<span class="nc" id="L538">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8890);int ch1 = this.read();</span>
<span class="nc" id="L539">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8891);int ch2 = this.read();</span>
<span class="nc bnc" id="L540" title="All 10 branches missed.">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8892);if (((((ch1 | ch2) &lt; 0)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8893)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8894)==0&amp;false))) {{</span>
<span class="nc" id="L541">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8895);throw new EOFException();</span>
        }
<span class="nc" id="L543">        }__CLR4_5_26sa6sam6lb4zlb.R.inc(8896);return (char)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));</span>
<span class="nc" id="L544">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads a Unicode character from this stream in little-endian order.
     * This method reads two
     * bytes from the stream, starting at the current stream pointer.
     * If the bytes read, in order, are
     * &lt;code&gt;b1&lt;/code&gt; and &lt;code&gt;b2&lt;/code&gt;, where
     * &lt;code&gt;0&amp;nbsp;&amp;lt;=&amp;nbsp;b1,&amp;nbsp;b2&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code&gt;,
     * then the result is equal to:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     (char)((b2 &amp;lt;&amp;lt; 8) | b1)
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next two bytes of this stream as a Unicode character.
     * @exception  EOFException  if this stream reaches the end before reading
     *               two bytes.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="nc" id="L566">    public final char readCharLE() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8897);</span>
<span class="nc" id="L567">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8898);int ch1 = this.read();</span>
<span class="nc" id="L568">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8899);int ch2 = this.read();</span>
<span class="nc bnc" id="L569" title="All 10 branches missed.">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8900);if (((((ch1 | ch2) &lt; 0)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8901)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8902)==0&amp;false))) {{</span>
<span class="nc" id="L570">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8903);throw new EOFException();</span>
        }
<span class="nc" id="L572">        }__CLR4_5_26sa6sam6lb4zlb.R.inc(8904);return (char)((ch2 &lt;&lt; 8) + (ch1 &lt;&lt; 0));</span>
<span class="nc" id="L573">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads a signed 32-bit integer from this stream. This method reads 4
     * bytes from the stream, starting at the current stream pointer.
     * If the bytes read, in order, are &lt;code&gt;b1&lt;/code&gt;,
     * &lt;code&gt;b2&lt;/code&gt;, &lt;code&gt;b3&lt;/code&gt;, and &lt;code&gt;b4&lt;/code&gt;, where
     * &lt;code&gt;0&amp;nbsp;&amp;lt;=&amp;nbsp;b1, b2, b3, b4&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code&gt;,
     * then the result is equal to:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     (b1 &amp;lt;&amp;lt; 24) | (b2 &amp;lt;&amp;lt; 16) + (b3 &amp;lt;&amp;lt; 8) + b4
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the four bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next four bytes of this stream, interpreted as an
     *             &lt;code&gt;int&lt;/code&gt;.
     * @exception  EOFException  if this stream reaches the end before reading
     *               four bytes.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="nc" id="L595">    public final int readInt() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8905);</span>
<span class="nc" id="L596">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8906);int ch1 = this.read();</span>
<span class="nc" id="L597">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8907);int ch2 = this.read();</span>
<span class="nc" id="L598">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8908);int ch3 = this.read();</span>
<span class="nc" id="L599">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8909);int ch4 = this.read();</span>
<span class="nc bnc" id="L600" title="All 10 branches missed.">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8910);if (((((ch1 | ch2 | ch3 | ch4) &lt; 0)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8911)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8912)==0&amp;false))) {{</span>
<span class="nc" id="L601">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8913);throw new EOFException();</span>
        }
<span class="nc" id="L603">        }__CLR4_5_26sa6sam6lb4zlb.R.inc(8914);return ((ch1 &lt;&lt; 24) + (ch2 &lt;&lt; 16) + (ch3 &lt;&lt; 8) + (ch4 &lt;&lt; 0));</span>
<span class="nc" id="L604">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads a signed 32-bit integer from this stream in little-endian order.
     * This method reads 4
     * bytes from the stream, starting at the current stream pointer.
     * If the bytes read, in order, are &lt;code&gt;b1&lt;/code&gt;,
     * &lt;code&gt;b2&lt;/code&gt;, &lt;code&gt;b3&lt;/code&gt;, and &lt;code&gt;b4&lt;/code&gt;, where
     * &lt;code&gt;0&amp;nbsp;&amp;lt;=&amp;nbsp;b1, b2, b3, b4&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code&gt;,
     * then the result is equal to:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     (b4 &amp;lt;&amp;lt; 24) | (b3 &amp;lt;&amp;lt; 16) + (b2 &amp;lt;&amp;lt; 8) + b1
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the four bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next four bytes of this stream, interpreted as an
     *             &lt;code&gt;int&lt;/code&gt;.
     * @exception  EOFException  if this stream reaches the end before reading
     *               four bytes.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="nc" id="L627">    public final int readIntLE() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8915);</span>
<span class="nc" id="L628">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8916);int ch1 = this.read();</span>
<span class="nc" id="L629">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8917);int ch2 = this.read();</span>
<span class="nc" id="L630">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8918);int ch3 = this.read();</span>
<span class="nc" id="L631">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8919);int ch4 = this.read();</span>
<span class="nc bnc" id="L632" title="All 10 branches missed.">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8920);if (((((ch1 | ch2 | ch3 | ch4) &lt; 0)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8921)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8922)==0&amp;false))) {{</span>
<span class="nc" id="L633">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8923);throw new EOFException();</span>
        }
<span class="nc" id="L635">        }__CLR4_5_26sa6sam6lb4zlb.R.inc(8924);return ((ch4 &lt;&lt; 24) + (ch3 &lt;&lt; 16) + (ch2 &lt;&lt; 8) + (ch1 &lt;&lt; 0));</span>
<span class="nc" id="L636">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads an unsigned 32-bit integer from this stream. This method reads 4
     * bytes from the stream, starting at the current stream pointer.
     * If the bytes read, in order, are &lt;code&gt;b1&lt;/code&gt;,
     * &lt;code&gt;b2&lt;/code&gt;, &lt;code&gt;b3&lt;/code&gt;, and &lt;code&gt;b4&lt;/code&gt;, where
     * &lt;code&gt;0&amp;nbsp;&amp;lt;=&amp;nbsp;b1, b2, b3, b4&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code&gt;,
     * then the result is equal to:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     (b1 &amp;lt;&amp;lt; 24) | (b2 &amp;lt;&amp;lt; 16) + (b3 &amp;lt;&amp;lt; 8) + b4
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the four bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next four bytes of this stream, interpreted as a
     *             &lt;code&gt;long&lt;/code&gt;.
     * @exception  EOFException  if this stream reaches the end before reading
     *               four bytes.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="fc" id="L658">    public final long readUnsignedInt() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8925);</span>
<span class="fc" id="L659">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8926);long ch1 = this.read();</span>
<span class="fc" id="L660">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8927);long ch2 = this.read();</span>
<span class="fc" id="L661">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8928);long ch3 = this.read();</span>
<span class="fc" id="L662">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8929);long ch4 = this.read();</span>
<span class="pc bpc" id="L663" title="7 of 10 branches missed.">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8930);if (((((ch1 | ch2 | ch3 | ch4) &lt; 0)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8931)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8932)==0&amp;false))) {{</span>
<span class="nc" id="L664">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8933);throw new EOFException();</span>
        }
<span class="fc" id="L666">        }__CLR4_5_26sa6sam6lb4zlb.R.inc(8934);return ((ch1 &lt;&lt; 24) + (ch2 &lt;&lt; 16) + (ch3 &lt;&lt; 8) + (ch4 &lt;&lt; 0));</span>
<span class="fc" id="L667">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

<span class="fc" id="L669">    private byte[] ruileBuf = new byte[4];</span>

    /**
     * Reads an unsigned 32-bit integer from this stream in little-endian
     * order.  This method reads 4
     * bytes from the stream, starting at the current stream pointer.
     * If the bytes read, in order, are &lt;code&gt;b1&lt;/code&gt;,
     * &lt;code&gt;b2&lt;/code&gt;, &lt;code&gt;b3&lt;/code&gt;, and &lt;code&gt;b4&lt;/code&gt;, where
     * &lt;code&gt;0&amp;nbsp;&amp;lt;=&amp;nbsp;b1, b2, b3, b4&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code&gt;,
     * then the result is equal to:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     (b4 &amp;lt;&amp;lt; 24) | (b3 &amp;lt;&amp;lt; 16) + (b2 &amp;lt;&amp;lt; 8) + b1
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the four bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next four bytes of this stream, interpreted as a
     *             &lt;code&gt;long&lt;/code&gt;.
     * @exception  EOFException  if this stream reaches the end before reading
     *               four bytes.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="fc" id="L692">    public final long readUnsignedIntLE() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8935);</span>
<span class="fc" id="L693">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8936);this.readFully(ruileBuf);</span>
<span class="fc" id="L694">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8937);long ch1 = (ruileBuf[0] &amp; 0xff);</span>
<span class="fc" id="L695">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8938);long ch2 = (ruileBuf[1] &amp; 0xff);</span>
<span class="fc" id="L696">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8939);long ch3 = (ruileBuf[2] &amp; 0xff);</span>
<span class="fc" id="L697">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8940);long ch4 = (ruileBuf[3] &amp; 0xff);</span>

<span class="fc" id="L699">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8941);return ((ch4 &lt;&lt; 24) + (ch3 &lt;&lt; 16) + (ch2 &lt;&lt; 8) + (ch1 &lt;&lt; 0));</span>
<span class="fc" id="L700">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads a signed 64-bit integer from this stream. This method reads eight
     * bytes from the stream, starting at the current stream pointer.
     * If the bytes read, in order, are
     * &lt;code&gt;b1&lt;/code&gt;, &lt;code&gt;b2&lt;/code&gt;, &lt;code&gt;b3&lt;/code&gt;,
     * &lt;code&gt;b4&lt;/code&gt;, &lt;code&gt;b5&lt;/code&gt;, &lt;code&gt;b6&lt;/code&gt;,
     * &lt;code&gt;b7&lt;/code&gt;, and &lt;code&gt;b8,&lt;/code&gt; where:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     0 &amp;lt;= b1, b2, b3, b4, b5, b6, b7, b8 &amp;lt;=255,
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * then the result is equal to:
     * &lt;p&gt;&lt;blockquote&gt;&lt;pre&gt;
     *     ((long)b1 &amp;lt;&amp;lt; 56) + ((long)b2 &amp;lt;&amp;lt; 48)
     *     + ((long)b3 &amp;lt;&amp;lt; 40) + ((long)b4 &amp;lt;&amp;lt; 32)
     *     + ((long)b5 &amp;lt;&amp;lt; 24) + ((long)b6 &amp;lt;&amp;lt; 16)
     *     + ((long)b7 &amp;lt;&amp;lt; 8) + b8
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the eight bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next eight bytes of this stream, interpreted as a
     *             &lt;code&gt;long&lt;/code&gt;.
     * @exception  EOFException  if this stream reaches the end before reading
     *               eight bytes.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="nc" id="L730">    public final long readLong() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8942);</span>
<span class="nc" id="L731">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8943);return ((long)(readInt()) &lt;&lt; 32) + (readInt() &amp; 0xFFFFFFFFL);</span>
<span class="nc" id="L732">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads a signed 64-bit integer from this stream in little-endian
     * order. This method reads eight
     * bytes from the stream, starting at the current stream pointer.
     * If the bytes read, in order, are
     * &lt;code&gt;b1&lt;/code&gt;, &lt;code&gt;b2&lt;/code&gt;, &lt;code&gt;b3&lt;/code&gt;,
     * &lt;code&gt;b4&lt;/code&gt;, &lt;code&gt;b5&lt;/code&gt;, &lt;code&gt;b6&lt;/code&gt;,
     * &lt;code&gt;b7&lt;/code&gt;, and &lt;code&gt;b8,&lt;/code&gt; where:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     0 &amp;lt;= b1, b2, b3, b4, b5, b6, b7, b8 &amp;lt;=255,
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * then the result is equal to:
     * &lt;p&gt;&lt;blockquote&gt;&lt;pre&gt;
     *     ((long)b1 &amp;lt;&amp;lt; 56) + ((long)b2 &amp;lt;&amp;lt; 48)
     *     + ((long)b3 &amp;lt;&amp;lt; 40) + ((long)b4 &amp;lt;&amp;lt; 32)
     *     + ((long)b5 &amp;lt;&amp;lt; 24) + ((long)b6 &amp;lt;&amp;lt; 16)
     *     + ((long)b7 &amp;lt;&amp;lt; 8) + b8
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the eight bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next eight bytes of this stream, interpreted as a
     *             &lt;code&gt;long&lt;/code&gt;.
     * @exception  EOFException  if this stream reaches the end before reading
     *               eight bytes.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="nc" id="L763">    public final long readLongLE() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8944);</span>
<span class="nc" id="L764">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8945);int i1 = readIntLE();</span>
<span class="nc" id="L765">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8946);int i2 = readIntLE();</span>
<span class="nc" id="L766">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8947);return ((long)i2 &lt;&lt; 32) + (i1 &amp; 0xFFFFFFFFL);</span>
<span class="nc" id="L767">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads a &lt;code&gt;float&lt;/code&gt; from this stream. This method reads an
     * &lt;code&gt;int&lt;/code&gt; value, starting at the current stream pointer,
     * as if by the &lt;code&gt;readInt&lt;/code&gt; method
     * and then converts that &lt;code&gt;int&lt;/code&gt; to a &lt;code&gt;float&lt;/code&gt;
     * using the &lt;code&gt;intBitsToFloat&lt;/code&gt; method in class
     * &lt;code&gt;Float&lt;/code&gt;.
     * &lt;p&gt;
     * This method blocks until the four bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next four bytes of this stream, interpreted as a
     *             &lt;code&gt;float&lt;/code&gt;.
     * @exception  EOFException  if this stream reaches the end before reading
     *             four bytes.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="nc" id="L786">    public final float readFloat() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8948);</span>
<span class="nc" id="L787">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8949);return Float.intBitsToFloat(readInt());</span>
<span class="nc" id="L788">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads a &lt;code&gt;float&lt;/code&gt; from this stream in little-endian order.
     * This method reads an
     * &lt;code&gt;int&lt;/code&gt; value, starting at the current stream pointer,
     * as if by the &lt;code&gt;readInt&lt;/code&gt; method
     * and then converts that &lt;code&gt;int&lt;/code&gt; to a &lt;code&gt;float&lt;/code&gt;
     * using the &lt;code&gt;intBitsToFloat&lt;/code&gt; method in class
     * &lt;code&gt;Float&lt;/code&gt;.
     * &lt;p&gt;
     * This method blocks until the four bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next four bytes of this stream, interpreted as a
     *             &lt;code&gt;float&lt;/code&gt;.
     * @exception  EOFException  if this stream reaches the end before reading
     *             four bytes.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="nc" id="L808">    public final float readFloatLE() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8950);</span>
<span class="nc" id="L809">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8951);return Float.intBitsToFloat(readIntLE());</span>
<span class="nc" id="L810">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads a &lt;code&gt;double&lt;/code&gt; from this stream. This method reads a
     * &lt;code&gt;long&lt;/code&gt; value, starting at the current stream pointer,
     * as if by the &lt;code&gt;readLong&lt;/code&gt; method
     * and then converts that &lt;code&gt;long&lt;/code&gt; to a &lt;code&gt;double&lt;/code&gt;
     * using the &lt;code&gt;longBitsToDouble&lt;/code&gt; method in
     * class &lt;code&gt;Double&lt;/code&gt;.
     * &lt;p&gt;
     * This method blocks until the eight bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next eight bytes of this stream, interpreted as a
     *             &lt;code&gt;double&lt;/code&gt;.
     * @exception  EOFException  if this stream reaches the end before reading
     *             eight bytes.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="nc" id="L829">    public final double readDouble() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8952);</span>
<span class="nc" id="L830">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8953);return Double.longBitsToDouble(readLong());</span>
<span class="nc" id="L831">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads a &lt;code&gt;double&lt;/code&gt; from this stream in little-endian order.
     * This method reads a
     * &lt;code&gt;long&lt;/code&gt; value, starting at the current stream pointer,
     * as if by the &lt;code&gt;readLong&lt;/code&gt; method
     * and then converts that &lt;code&gt;long&lt;/code&gt; to a &lt;code&gt;double&lt;/code&gt;
     * using the &lt;code&gt;longBitsToDouble&lt;/code&gt; method in
     * class &lt;code&gt;Double&lt;/code&gt;.
     * &lt;p&gt;
     * This method blocks until the eight bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next eight bytes of this stream, interpreted as a
     *             &lt;code&gt;double&lt;/code&gt;.
     * @exception  EOFException  if this stream reaches the end before reading
     *             eight bytes.
     * @exception  IOException   if an I/O error occurs.
     */
<span class="nc" id="L851">    public final double readDoubleLE() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8954);</span>
<span class="nc" id="L852">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8955);return Double.longBitsToDouble(readLongLE());</span>
<span class="nc" id="L853">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads the next line of text from this stream.  This method successively
     * reads bytes from the stream, starting at the current stream pointer,
     * until it reaches a line terminator or the end
     * of the stream.  Each byte is converted into a character by taking the
     * byte's value for the lower eight bits of the character and setting the
     * high eight bits of the character to zero.  This method does not,
     * therefore, support the full Unicode character set.
     *
     * &lt;p&gt; A line of text is terminated by a carriage-return character
     * (&lt;code&gt;'&amp;#92;r'&lt;/code&gt;), a newline character (&lt;code&gt;'&amp;#92;n'&lt;/code&gt;), a
     * carriage-return character immediately followed by a newline character,
     * or the end of the stream.  Line-terminating characters are discarded and
     * are not included as part of the string returned.
     *
     * &lt;p&gt; This method blocks until a newline character is read, a carriage
     * return and the byte following it are read (to see if it is a newline),
     * the end of the stream is reached, or an exception is thrown.
     *
     * @return     the next line of text from this stream, or null if end
     *             of stream is encountered before even one byte is read.
     * @exception  IOException  if an I/O error occurs.
     */
<span class="nc" id="L878">    public final String readLine() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8956);</span>
<span class="nc" id="L879">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8957);StringBuffer input = new StringBuffer();</span>
<span class="nc" id="L880">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8958);int c = -1;</span>
<span class="nc" id="L881">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8959);boolean eol = false;</span>

<span class="nc bnc" id="L883" title="All 10 branches missed.">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8960);while ((((!eol)&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8961)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8962)==0&amp;false))) {{</span>
<span class="nc" id="L884">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8963);c = read();</span>
<span class="nc bnc" id="L885" title="All 4 branches missed.">            boolean __CLB4_5_2_bool0=false;__CLR4_5_26sa6sam6lb4zlb.R.inc(8964);switch (c) {</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">            case -1:if (!__CLB4_5_2_bool0) {__CLR4_5_26sa6sam6lb4zlb.R.inc(8965);__CLB4_5_2_bool0=true;}</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">            case '\n':if (!__CLB4_5_2_bool0) {__CLR4_5_26sa6sam6lb4zlb.R.inc(8966);__CLB4_5_2_bool0=true;}</span>
<span class="nc" id="L888">                __CLR4_5_26sa6sam6lb4zlb.R.inc(8967);eol = true;</span>
<span class="nc" id="L889">                __CLR4_5_26sa6sam6lb4zlb.R.inc(8968);break;</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">            case '\r':if (!__CLB4_5_2_bool0) {__CLR4_5_26sa6sam6lb4zlb.R.inc(8969);__CLB4_5_2_bool0=true;}</span>
<span class="nc" id="L891">                __CLR4_5_26sa6sam6lb4zlb.R.inc(8970);eol = true;</span>
<span class="nc" id="L892">                __CLR4_5_26sa6sam6lb4zlb.R.inc(8971);long cur = getFilePointer();</span>
<span class="nc bnc" id="L893" title="All 10 branches missed.">                __CLR4_5_26sa6sam6lb4zlb.R.inc(8972);if (((((read()) != '\n')&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8973)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8974)==0&amp;false))) {{</span>
<span class="nc" id="L894">                    __CLR4_5_26sa6sam6lb4zlb.R.inc(8975);seek(cur);</span>
                }
<span class="nc" id="L896">                }__CLR4_5_26sa6sam6lb4zlb.R.inc(8976);break;</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">            default:if (!__CLB4_5_2_bool0) {__CLR4_5_26sa6sam6lb4zlb.R.inc(8977);__CLB4_5_2_bool0=true;}</span>
<span class="nc" id="L898">                __CLR4_5_26sa6sam6lb4zlb.R.inc(8978);input.append((char)c);</span>
<span class="nc" id="L899">                __CLR4_5_26sa6sam6lb4zlb.R.inc(8979);break;</span>
            }
<span class="nc" id="L901">        }</span>

<span class="nc bnc" id="L903" title="All 12 branches missed.">        }__CLR4_5_26sa6sam6lb4zlb.R.inc(8980);if (((((c == -1) &amp;&amp; (input.length() == 0))&amp;&amp;(__CLR4_5_26sa6sam6lb4zlb.R.iget(8981)!=0|true))||(__CLR4_5_26sa6sam6lb4zlb.R.iget(8982)==0&amp;false))) {{</span>
<span class="nc" id="L904">            __CLR4_5_26sa6sam6lb4zlb.R.inc(8983);return null;</span>
        }
<span class="nc" id="L906">        }__CLR4_5_26sa6sam6lb4zlb.R.inc(8984);return input.toString();</span>
<span class="nc" id="L907">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Reads in a string from this stream. The string has been encoded
     * using a modified UTF-8 format.
     * &lt;p&gt;
     * The first two bytes are read, starting from the current stream
     * pointer, as if by
     * &lt;code&gt;readUnsignedShort&lt;/code&gt;. This value gives the number of
     * following bytes that are in the encoded string, not
     * the length of the resulting string. The following bytes are then
     * interpreted as bytes encoding characters in the UTF-8 format
     * and are converted into characters.
     * &lt;p&gt;
     * This method blocks until all the bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     a Unicode string.
     * @exception  EOFException            if this stream reaches the end before
     *               reading all the bytes.
     * @exception  IOException             if an I/O error occurs.
     * @exception  java.io.UTFDataFormatException  if the bytes do not represent
     *               valid UTF-8 encoding of a Unicode string.
     */
<span class="nc" id="L931">    public final String readUTF() throws IOException {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8985);</span>
<span class="nc" id="L932">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8986);return DataInputStream.readUTF(this);</span>
<span class="nc" id="L933">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>

    /**
     * Releases any system resources associated with this stream
     * by calling the &lt;code&gt;close()&lt;/code&gt; method.
     */
<span class="fc" id="L939">    protected void finalize() throws Throwable {try{__CLR4_5_26sa6sam6lb4zlb.R.inc(8987);</span>
<span class="fc" id="L940">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8988);super.finalize();</span>
<span class="fc" id="L941">        __CLR4_5_26sa6sam6lb4zlb.R.inc(8989);close();</span>
<span class="fc" id="L942">    }finally{__CLR4_5_26sa6sam6lb4zlb.R.flushNeeded();}}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>