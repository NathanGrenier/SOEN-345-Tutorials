<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TIFFImageEncoder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">org.apache.xmlgraphics:xmlgraphics-commons</a> &gt; <a href="index.source.html" class="el_package">org.apache.xmlgraphics.image.codec.tiff</a> &gt; <span class="el_source">TIFFImageEncoder.java</span></div><h1>TIFFImageEncoder.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* $Id: TIFFImageEncoder.java 1804124 2017-08-04 14:13:54Z ssteiner $ */

package org.apache.xmlgraphics.image.codec.tiff;

import java.awt.Rectangle;
import java.awt.image.ColorModel;
import java.awt.image.ComponentSampleModel;
import java.awt.image.DataBuffer;
import java.awt.image.DataBufferByte;
import java.awt.image.IndexColorModel;
import java.awt.image.MultiPixelPackedSampleModel;
import java.awt.image.Raster;
import java.awt.image.RenderedImage;
import java.awt.image.SampleModel;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.zip.Deflater;

import org.apache.xmlgraphics.image.codec.util.ImageEncodeParam;
import org.apache.xmlgraphics.image.codec.util.ImageEncoderImpl;
import org.apache.xmlgraphics.image.codec.util.PropertyUtil;
import org.apache.xmlgraphics.image.codec.util.SeekableOutputStream;

// CSOFF: ConstantName
// CSOFF: MissingSwitchDefault
// CSOFF: MultipleVariableDeclarations
// CSOFF: OperatorWrap
// CSOFF: WhitespaceAround

/**
 * A baseline TIFF writer. The writer outputs TIFF images in either Bilevel,
 * Greyscale, Palette color or Full Color modes.
 *
 */
public class TIFFImageEncoder extends ImageEncoderImpl {

    // Incidental tags
    private static final int TIFF_JPEG_TABLES       = 347;
    private static final int TIFF_YCBCR_SUBSAMPLING = 530;
    private static final int TIFF_YCBCR_POSITIONING = 531;
    private static final int TIFF_REF_BLACK_WHITE   = 532;



    public TIFFImageEncoder(OutputStream output, ImageEncodeParam param) {
<span class="fc" id="L73">        super(output, param);</span>
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">        if (this.param == null) {</span>
<span class="fc" id="L75">            this.param = new TIFFEncodeParam();</span>
        }
<span class="fc" id="L77">    }</span>

    /**
     * Encodes a RenderedImage and writes the output to the
     * OutputStream associated with this ImageEncoder.
     */
    public void encode(RenderedImage im) throws IOException {
        // Write the file header (8 bytes).
<span class="fc" id="L85">        writeFileHeader();</span>

        // Get the encoding parameters.
<span class="fc" id="L88">        TIFFEncodeParam encodeParam = (TIFFEncodeParam)param;</span>

<span class="fc" id="L90">        Iterator iter = encodeParam.getExtraImages();</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">        if (iter != null) {</span>
<span class="nc" id="L92">            int ifdOffset = 8;</span>
<span class="nc" id="L93">            RenderedImage nextImage = im;</span>
<span class="nc" id="L94">            TIFFEncodeParam nextParam = encodeParam;</span>
            boolean hasNext;
            do {
<span class="nc" id="L97">                hasNext = iter.hasNext();</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                ifdOffset = encode(nextImage, nextParam, ifdOffset, !hasNext);</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">                if (hasNext) {</span>
<span class="nc" id="L100">                    Object obj = iter.next();</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">                    if (obj instanceof RenderedImage) {</span>
<span class="nc" id="L102">                        nextImage = (RenderedImage)obj;</span>
<span class="nc" id="L103">                        nextParam = encodeParam;</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">                    } else if (obj instanceof Object[]) {</span>
<span class="nc" id="L105">                        Object[] o = (Object[])obj;</span>
<span class="nc" id="L106">                        nextImage = (RenderedImage)o[0];</span>
<span class="nc" id="L107">                        nextParam = (TIFFEncodeParam)o[1];</span>
                    }
                }
<span class="nc bnc" id="L110" title="All 2 branches missed.">            } while(hasNext);</span>
<span class="nc" id="L111">        } else {</span>
<span class="fc" id="L112">            encode(im, encodeParam, 8, true);</span>
        }
<span class="fc" id="L114">    }</span>

    /**
     * Encodes a RenderedImage as part of a multi-page file and writes the output to the
     * OutputStream associated with this ImageEncoder.
     * &lt;p&gt;
     * When you sent all pages, make sure you call finishMultiple() in the end. Otherwise,
     * the generated file will be corrupted.
     * @param context the context object you receive as return value to a previous call to
     *                encodeMultiple(). Set null for the first image.
     * @param img the image
     * @return a context object needed for writing multiple pages for a single image file
     * @throws IOException In case of an I/O error
     */
    public Object encodeMultiple(Object context, RenderedImage img) throws IOException {
        // Get the encoding parameters.
<span class="nc" id="L130">        TIFFEncodeParam encodeParam = (TIFFEncodeParam)param;</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (encodeParam.getExtraImages() != null) {</span>
<span class="nc" id="L132">            throw new IllegalStateException(PropertyUtil.getString(&quot;TIFFImageEncoder11&quot;));</span>
        }

<span class="nc" id="L135">        Context c = (Context)context;</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L137">            c = new Context();</span>
            // Write the file header (8 bytes).
<span class="nc" id="L139">            writeFileHeader();</span>
        } else {
            //write image
<span class="nc" id="L142">            c.ifdOffset = encode(c.nextImage, encodeParam, c.ifdOffset, false);</span>
        }
<span class="nc" id="L144">        c.nextImage = img;</span>
<span class="nc" id="L145">        return c;</span>
    }

    /**
     * Signals the encoder that you've finished sending pages for a multi-page image files.
     * @param context the context object you receive as return value to a previous call to
     *                encodeMultiple()
     * @throws IOException In case of an I/O error
     */
    public void finishMultiple(Object context) throws IOException {
<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (context == null) {</span>
<span class="nc" id="L156">            throw new NullPointerException();</span>
        }
<span class="nc" id="L158">        Context c = (Context)context;</span>
        // Get the encoding parameters.
<span class="nc" id="L160">        TIFFEncodeParam encodeParam = (TIFFEncodeParam)param;</span>

        //write last image
<span class="nc" id="L163">        c.ifdOffset = encode(c.nextImage, encodeParam, c.ifdOffset, true);</span>
<span class="nc" id="L164">    }</span>

<span class="nc" id="L166">    private static class Context {</span>
        //TODO This approach causes always two images to be present at the same time.
        //The encoder has to be changed a little to avoid that.
        private RenderedImage nextImage;
<span class="nc" id="L170">        private int ifdOffset = 8; //Initial offset</span>
    }

    private int encode(RenderedImage im, TIFFEncodeParam encodeParam,
                       int ifdOffset, boolean isLast) throws IOException {
        // Currently all images are stored uncompressed.
<span class="fc" id="L176">        CompressionValue compression = encodeParam.getCompression();</span>

<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        if (compression == CompressionValue.JPEG_TTN2) {</span>
<span class="nc" id="L179">            throw new IllegalArgumentException(PropertyUtil.getString(&quot;TIFFImageEncoder12&quot;));</span>
        }

        // Get tiled output preference.
<span class="fc" id="L183">        boolean isTiled = encodeParam.getWriteTiled();</span>

        // Set bounds.
<span class="fc" id="L186">        int minX = im.getMinX();</span>
<span class="fc" id="L187">        int minY = im.getMinY();</span>
<span class="fc" id="L188">        int width = im.getWidth();</span>
<span class="fc" id="L189">        int height = im.getHeight();</span>

        // Get SampleModel.
<span class="fc" id="L192">        SampleModel sampleModel = im.getSampleModel();</span>
<span class="fc" id="L193">        ColorModel colorModel = im.getColorModel();</span>
<span class="fc" id="L194">        int[] sampleSize = sampleModel.getSampleSize();</span>
<span class="fc" id="L195">        int dataTypeSize = sampleSize[0];</span>
<span class="fc" id="L196">        int numBands = sampleModel.getNumBands();</span>
<span class="fc" id="L197">        int dataType = sampleModel.getDataType();</span>
<span class="fc" id="L198">        validateImage(dataTypeSize, sampleSize, numBands, dataType, colorModel);</span>

<span class="pc bpc" id="L200" title="2 of 4 branches missed.">        boolean dataTypeIsShort = dataType == DataBuffer.TYPE_SHORT</span>
                || dataType == DataBuffer.TYPE_USHORT;

        // Set image type.
<span class="fc" id="L204">        ImageInfo imageInfo = ImageInfo.newInstance(im, dataTypeSize, numBands, colorModel,</span>
                encodeParam);

<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (imageInfo.getType() == ImageType.UNSUPPORTED) {</span>
<span class="nc" id="L208">            throw new RuntimeException(PropertyUtil.getString(&quot;TIFFImageEncoder8&quot;));</span>
        }

<span class="fc" id="L211">        final int numTiles = imageInfo.getNumTiles();</span>
<span class="fc" id="L212">        final long bytesPerTile = imageInfo.getBytesPerTile();</span>
<span class="fc" id="L213">        final long bytesPerRow = imageInfo.getBytesPerRow();</span>
<span class="fc" id="L214">        final int tileHeight = imageInfo.getTileHeight();</span>
<span class="fc" id="L215">        final int tileWidth = imageInfo.getTileWidth();</span>

<span class="fc" id="L217">        long[] tileByteCounts = new long[numTiles];</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">        for (int i = 0; i &lt; numTiles; i++) {</span>
<span class="fc" id="L219">            tileByteCounts[i] = bytesPerTile;</span>
        }

<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        if (!isTiled) {</span>
            // Last strip may have lesser rows
<span class="fc" id="L224">            long lastStripRows = height - (tileHeight * (numTiles - 1));</span>
<span class="fc" id="L225">            tileByteCounts[numTiles - 1] = lastStripRows * bytesPerRow;</span>
        }
<span class="fc" id="L227">        long totalBytesOfData = bytesPerTile * (numTiles - 1) + tileByteCounts[numTiles - 1];</span>
<span class="fc" id="L228">        long[] tileOffsets = new long[numTiles];</span>

        // Basic fields - have to be in increasing numerical order.
        // ImageWidth                     256
        // ImageLength                    257
        // BitsPerSample                  258
        // Compression                    259
        // PhotoMetricInterpretation      262
        // StripOffsets                   273
        // RowsPerStrip                   278
        // StripByteCounts                279
        // XResolution                    282
        // YResolution                    283
        // ResolutionUnit                 296

        // Create Directory
<span class="fc" id="L244">        SortedSet&lt;TIFFField&gt; fields = new TreeSet&lt;TIFFField&gt;();</span>

        // Image Width
<span class="fc" id="L247">        fields.add(new TIFFField(TIFFImageDecoder.TIFF_IMAGE_WIDTH,</span>
                                 TIFFField.TIFF_LONG, 1,
                                 new long[] {width}));

        // Image Length
<span class="fc" id="L252">        fields.add(new TIFFField(TIFFImageDecoder.TIFF_IMAGE_LENGTH,</span>
                                 TIFFField.TIFF_LONG, 1,
                                 new long[] {height}));

<span class="fc" id="L256">        char [] shortSampleSize = new char[numBands];</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">        for (int i = 0; i &lt; numBands; i++) {</span>
<span class="fc" id="L258">            shortSampleSize[i] = (char) dataTypeSize;</span>
        }
<span class="fc" id="L260">        fields.add(new TIFFField(TIFFImageDecoder.TIFF_BITS_PER_SAMPLE,</span>
                                 TIFFField.TIFF_SHORT, numBands,
                                 shortSampleSize));

<span class="fc" id="L264">        fields.add(new TIFFField(TIFFImageDecoder.TIFF_COMPRESSION,</span>
                                 TIFFField.TIFF_SHORT, 1,
<span class="fc" id="L266">                                 new char[] {(char)compression.getValue()}));</span>

<span class="fc" id="L268">        fields.add(</span>
            new TIFFField(TIFFImageDecoder.TIFF_PHOTOMETRIC_INTERPRETATION,
                          TIFFField.TIFF_SHORT, 1,
<span class="fc" id="L271">                      new char[] {(char) imageInfo.getType().getPhotometricInterpretation()}));</span>

<span class="pc bpc" id="L273" title="1 of 2 branches missed.">        if (!isTiled) {</span>
<span class="fc" id="L274">            fields.add(new TIFFField(TIFFImageDecoder.TIFF_STRIP_OFFSETS,</span>
                                     TIFFField.TIFF_LONG, numTiles,
                                     tileOffsets));
        }

<span class="fc" id="L279">        fields.add(new TIFFField(TIFFImageDecoder.TIFF_SAMPLES_PER_PIXEL,</span>
                                 TIFFField.TIFF_SHORT, 1,
                                 new char[] {(char)numBands}));

<span class="pc bpc" id="L283" title="1 of 2 branches missed.">        if (!isTiled) {</span>
<span class="fc" id="L284">            fields.add(new TIFFField(TIFFImageDecoder.TIFF_ROWS_PER_STRIP,</span>
                                     TIFFField.TIFF_LONG, 1,
                                     new long[] {tileHeight}));

<span class="fc" id="L288">            fields.add(new TIFFField(TIFFImageDecoder.TIFF_STRIP_BYTE_COUNTS,</span>
                                     TIFFField.TIFF_LONG, numTiles,
                                     tileByteCounts));
        }

<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        if (imageInfo.getColormap() != null) {</span>
<span class="nc" id="L294">            fields.add(new TIFFField(TIFFImageDecoder.TIFF_COLORMAP,</span>
<span class="nc" id="L295">                    TIFFField.TIFF_SHORT, imageInfo.getColormapSize(),</span>
<span class="nc" id="L296">                    imageInfo.getColormap()));</span>
        }

<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if (isTiled) {</span>
<span class="nc" id="L300">            fields.add(new TIFFField(TIFFImageDecoder.TIFF_TILE_WIDTH,</span>
                                     TIFFField.TIFF_LONG, 1,
                                     new long[] {tileWidth}));

<span class="nc" id="L304">            fields.add(new TIFFField(TIFFImageDecoder.TIFF_TILE_LENGTH,</span>
                                     TIFFField.TIFF_LONG, 1,
                                     new long[] {tileHeight}));

<span class="nc" id="L308">            fields.add(new TIFFField(TIFFImageDecoder.TIFF_TILE_OFFSETS,</span>
                                     TIFFField.TIFF_LONG, numTiles,
                                     tileOffsets));

<span class="nc" id="L312">            fields.add(new TIFFField(TIFFImageDecoder.TIFF_TILE_BYTE_COUNTS,</span>
                                     TIFFField.TIFF_LONG, numTiles,
                                     tileByteCounts));
        }

<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        if (imageInfo.getNumberOfExtraSamples() &gt; 0) {</span>
<span class="nc" id="L318">            char[] extraSamples = new char[imageInfo.getNumberOfExtraSamples()];</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">            for (int i = 0; i &lt; imageInfo.getNumberOfExtraSamples(); i++) {</span>
<span class="nc" id="L320">                extraSamples[i] = (char) imageInfo.getExtraSamplesType().getValue();</span>
            }
<span class="nc" id="L322">            fields.add(new TIFFField(TIFFImageDecoder.TIFF_EXTRA_SAMPLES,</span>
<span class="nc" id="L323">                    TIFFField.TIFF_SHORT, imageInfo.getNumberOfExtraSamples(),</span>
                                     extraSamples));
        }

        // Data Sample Format Extension fields.
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        if (dataType != DataBuffer.TYPE_BYTE) {</span>
            // SampleFormat
<span class="nc" id="L330">            char[] sampleFormat = new char[numBands];</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">            if (dataType == DataBuffer.TYPE_FLOAT) {</span>
<span class="nc" id="L332">                sampleFormat[0] = 3;</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">            } else if (dataType == DataBuffer.TYPE_USHORT) {</span>
<span class="nc" id="L334">                sampleFormat[0] = 1;</span>
            } else {
<span class="nc" id="L336">                sampleFormat[0] = 2;</span>
            }
<span class="nc bnc" id="L338" title="All 2 branches missed.">            for (int b = 1; b &lt; numBands; b++) {</span>
<span class="nc" id="L339">                sampleFormat[b] = sampleFormat[0];</span>
            }
<span class="nc" id="L341">            fields.add(new TIFFField(TIFFImageDecoder.TIFF_SAMPLE_FORMAT,</span>
                                     TIFFField.TIFF_SHORT, numBands,
                                     sampleFormat));

            // NOTE: We don't bother setting the SMinSampleValue and
            // SMaxSampleValue fields as these both default to the
            // extrema of the respective data types.  Probably we should
            // check for the presence of the &quot;extrema&quot; property and
            // use it if available.
        }

<span class="pc bpc" id="L352" title="1 of 2 branches missed.">        if (imageInfo.getType() == ImageType.YCBCR) {</span>
            // YCbCrSubSampling: 2 is the default so we must write 1 as
            // we do not (yet) do any subsampling.
<span class="nc" id="L355">            char subsampleH = 1;</span>
<span class="nc" id="L356">            char subsampleV = 1;</span>

<span class="nc" id="L358">            fields.add(new TIFFField(TIFF_YCBCR_SUBSAMPLING,</span>
                                     TIFFField.TIFF_SHORT, 2,
                                     new char[] {subsampleH, subsampleV}));


            // YCbCr positioning.
<span class="nc" id="L364">            fields.add(new TIFFField(TIFF_YCBCR_POSITIONING,</span>
                                     TIFFField.TIFF_SHORT, 1,
                                     new char[]
<span class="nc bnc" id="L367" title="All 2 branches missed.">                    {(char) ((compression == CompressionValue.JPEG_TTN2) ? 1 : 2)}));</span>

            // Reference black/white.
            long[][] refbw;
<span class="nc" id="L371">            refbw = new long[][] // CCIR 601.1 headroom/footroom (presumptive)</span>
                    {{15, 1}, {235, 1}, {128, 1}, {240, 1}, {128, 1}, {240, 1}};

<span class="nc" id="L374">            fields.add(new TIFFField(TIFF_REF_BLACK_WHITE,</span>
                                     TIFFField.TIFF_RATIONAL, 6,
                                     refbw));
        }

        // ---- No more automatically generated fields should be added
        //      after this point. ----

        // Add extra fields specified via the encoding parameters.
<span class="fc" id="L383">        TIFFField[] extraFields = encodeParam.getExtraFields();</span>
<span class="fc" id="L384">        List extantTags = new ArrayList(fields.size());</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">        for (TIFFField fld : fields) {</span>
<span class="fc" id="L386">            extantTags.add(fld.getTag());</span>
<span class="fc" id="L387">        }</span>

<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        for (TIFFField fld : extraFields) {</span>
<span class="nc" id="L390">            Integer tagValue = fld.getTag();</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">            if (!extantTags.contains(tagValue)) {</span>
<span class="nc" id="L392">                fields.add(fld);</span>
<span class="nc" id="L393">                extantTags.add(tagValue);</span>
            }
        }

        // ---- No more fields of any type should be added after this. ----

        // Determine the size of the IFD which is written after the header
        // of the stream or after the data of the previous image in a
        // multi-page stream.
<span class="fc" id="L402">        int dirSize = getDirectorySize(fields);</span>

        // The first data segment is written after the field overflow
        // following the IFD so initialize the first offset accordingly.
<span class="fc" id="L406">        tileOffsets[0] = ifdOffset + dirSize;</span>

        // Branch here depending on whether data are being compressed.
        // If not, then the IFD is written immediately.
        // If so then there are three possibilities:
        // A) the OutputStream is a SeekableOutputStream (outCache null);
        // B) the OutputStream is not a SeekableOutputStream and a file cache
        //    is used (outCache non-null, tempFile non-null);
        // C) the OutputStream is not a SeekableOutputStream and a memory cache
        //    is used (outCache non-null, tempFile null).

<span class="fc" id="L417">        OutputStream outCache = null;</span>
<span class="fc" id="L418">        byte[] compressBuf = null;</span>
<span class="fc" id="L419">        File tempFile = null;</span>

<span class="fc" id="L421">        int nextIFDOffset = 0;</span>
<span class="fc" id="L422">        boolean skipByte = false;</span>

<span class="fc" id="L424">        Deflater deflater = null;</span>
<span class="fc" id="L425">        boolean jpegRGBToYCbCr = false;</span>

<span class="pc bpc" id="L427" title="1 of 2 branches missed.">        if (compression == CompressionValue.NONE) {</span>
            // Determine the number of bytes of padding necessary between
            // the end of the IFD and the first data segment such that the
            // alignment of the data conforms to the specification (required
            // for uncompressed data only).
<span class="fc" id="L432">            int numBytesPadding = 0;</span>
<span class="pc bpc" id="L433" title="3 of 4 branches missed.">            if (dataTypeSize == 16 &amp;&amp; tileOffsets[0] % 2 != 0) {</span>
<span class="nc" id="L434">                numBytesPadding = 1;</span>
<span class="nc" id="L435">                tileOffsets[0]++;</span>
<span class="pc bpc" id="L436" title="3 of 4 branches missed.">            } else if (dataTypeSize == 32 &amp;&amp; tileOffsets[0] % 4 != 0) {</span>
<span class="nc" id="L437">                numBytesPadding = (int)(4 - tileOffsets[0] % 4);</span>
<span class="nc" id="L438">                tileOffsets[0] += numBytesPadding;</span>
            }

            // Update the data offsets (which TIFFField stores by reference).
<span class="fc bfc" id="L442" title="All 2 branches covered.">            for (int i = 1; i &lt; numTiles; i++) {</span>
<span class="fc" id="L443">                tileOffsets[i] = tileOffsets[i - 1] + tileByteCounts[i - 1];</span>
            }

<span class="pc bpc" id="L446" title="1 of 2 branches missed.">            if (!isLast) {</span>
                // Determine the offset of the next IFD.
<span class="nc" id="L448">                nextIFDOffset = (int)(tileOffsets[0] + totalBytesOfData);</span>

                // IFD offsets must be on a word boundary.
<span class="nc bnc" id="L451" title="All 2 branches missed.">                if ((nextIFDOffset &amp; 0x01) != 0) {</span>
<span class="nc" id="L452">                    nextIFDOffset++;</span>
<span class="nc" id="L453">                    skipByte = true;</span>
                }
            }

            // Write the IFD and field overflow before the image data.
<span class="fc" id="L458">            writeDirectory(ifdOffset, fields, nextIFDOffset);</span>

            // Write any padding bytes needed between the end of the IFD
            // and the start of the actual image data.
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">            if (numBytesPadding != 0) {</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                for (int padding = 0; padding &lt; numBytesPadding; padding++) {</span>
<span class="nc" id="L464">                    output.write((byte)0);</span>
                }
            }
<span class="fc" id="L467">        } else {</span>
            // If compressing, the cannot be written yet as the size of the
            // data segments is unknown.

<span class="nc bnc" id="L471" title="All 2 branches missed.">            if (output instanceof SeekableOutputStream) {</span>
                // Simply seek to the first data segment position.
<span class="nc" id="L473">                ((SeekableOutputStream)output).seek(tileOffsets[0]);</span>
            } else {
                // Cache the original OutputStream.
<span class="nc" id="L476">                outCache = output;</span>

                try {
                    // Attempt to create a temporary file.
<span class="nc" id="L480">                    tempFile = File.createTempFile(&quot;jai-SOS-&quot;, &quot;.tmp&quot;);</span>
<span class="nc" id="L481">                    tempFile.deleteOnExit();</span>
<span class="nc" id="L482">                    RandomAccessFile raFile = new RandomAccessFile(tempFile, &quot;rw&quot;);</span>
<span class="nc" id="L483">                    output = new SeekableOutputStream(raFile);</span>

                    // this method is exited!
<span class="nc" id="L486">                } catch (IOException e) {</span>
                    // Allocate memory for the entire image data (!).
<span class="nc" id="L488">                    output = new ByteArrayOutputStream((int)totalBytesOfData);</span>
<span class="nc" id="L489">                }</span>
            }

<span class="nc" id="L492">            int bufSize = 0;</span>
<span class="nc bnc" id="L493" title="All 3 branches missed.">            switch(compression) {</span>
            case PACKBITS:
<span class="nc" id="L495">                bufSize = (int) (bytesPerTile + ((bytesPerRow + 127) / 128) * tileHeight);</span>
<span class="nc" id="L496">                break;</span>
            case DEFLATE:
<span class="nc" id="L498">                bufSize = (int) bytesPerTile;</span>
<span class="nc" id="L499">                deflater = new Deflater(encodeParam.getDeflateLevel());</span>
<span class="nc" id="L500">                break;</span>
            default:
<span class="nc" id="L502">                bufSize = 0;</span>
            }
<span class="nc bnc" id="L504" title="All 2 branches missed.">            if (bufSize != 0) {</span>
<span class="nc" id="L505">                compressBuf = new byte[bufSize];</span>
            }
        }

        // ---- Writing of actual image data ----

        // Buffer for up to tileHeight rows of pixels
<span class="fc" id="L512">        int[] pixels = null;</span>
<span class="fc" id="L513">        float[] fpixels = null;</span>

        // Whether to test for contiguous data.
<span class="pc bpc" id="L516" title="4 of 10 branches missed.">        boolean checkContiguous =</span>
            ((dataTypeSize == 1
              &amp;&amp; sampleModel instanceof MultiPixelPackedSampleModel
              &amp;&amp; dataType == DataBuffer.TYPE_BYTE)
             || (dataTypeSize == 8
              &amp;&amp; sampleModel instanceof ComponentSampleModel));

        // Also create a buffer to hold tileHeight lines of the
        // data to be written to the file, so we can use array writes.
<span class="fc" id="L525">        byte[] bpixels = null;</span>
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">        if (compression != CompressionValue.JPEG_TTN2) {</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">            if (dataType == DataBuffer.TYPE_BYTE) {</span>
<span class="fc" id="L528">                bpixels = new byte[tileHeight * tileWidth * numBands];</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">            } else if (dataTypeIsShort) {</span>
<span class="nc" id="L530">                bpixels = new byte[2 * tileHeight * tileWidth * numBands];</span>
<span class="nc bnc" id="L531" title="All 4 branches missed.">            } else if (dataType == DataBuffer.TYPE_INT</span>
                      || dataType == DataBuffer.TYPE_FLOAT) {
<span class="nc" id="L533">                bpixels = new byte[4 * tileHeight * tileWidth * numBands];</span>
            }
        }

        // Process tileHeight rows at a time
<span class="fc" id="L538">        int lastRow = minY + height;</span>
<span class="fc" id="L539">        int lastCol = minX + width;</span>
<span class="fc" id="L540">        int tileNum = 0;</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">        for (int row = minY; row &lt; lastRow; row += tileHeight) {</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">            int rows = isTiled</span>
<span class="pc" id="L543">                ? tileHeight : Math.min(tileHeight, lastRow - row);</span>
<span class="fc" id="L544">            int size = rows * tileWidth * numBands;</span>

<span class="fc bfc" id="L546" title="All 2 branches covered.">            for (int col = minX; col &lt; lastCol; col += tileWidth) {</span>
                // Grab the pixels
<span class="fc" id="L548">                Raster src =</span>
<span class="fc" id="L549">                    im.getData(new Rectangle(col, row, tileWidth, rows));</span>

<span class="fc" id="L551">                boolean useDataBuffer = false;</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">                if (compression != CompressionValue.JPEG_TTN2) { // JPEG access Raster</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">                    if (checkContiguous) {</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">                        if (dataTypeSize == 8) { // 8-bit</span>
<span class="fc" id="L555">                            ComponentSampleModel csm =</span>
<span class="fc" id="L556">                                (ComponentSampleModel)src.getSampleModel();</span>
<span class="fc" id="L557">                            int[] bankIndices = csm.getBankIndices();</span>
<span class="fc" id="L558">                            int[] bandOffsets = csm.getBandOffsets();</span>
<span class="fc" id="L559">                            int pixelStride = csm.getPixelStride();</span>
<span class="fc" id="L560">                            int lineStride = csm.getScanlineStride();</span>

<span class="pc bpc" id="L562" title="2 of 4 branches missed.">                            if (pixelStride != numBands</span>
                               || lineStride != bytesPerRow) {
<span class="nc" id="L564">                                useDataBuffer = false;</span>
                            } else {
<span class="fc" id="L566">                                useDataBuffer = true;</span>
<span class="fc" id="L567">                                for (int i = 0;</span>
<span class="pc bpc" id="L568" title="1 of 4 branches missed.">                                    useDataBuffer &amp;&amp; i &lt; numBands;</span>
<span class="fc" id="L569">                                    i++) {</span>
<span class="pc bpc" id="L570" title="2 of 4 branches missed.">                                    if (bankIndices[i] != 0</span>
                                       || bandOffsets[i] != i) {
<span class="nc" id="L572">                                        useDataBuffer = false;</span>
                                    }
                                }
                            }
<span class="fc" id="L576">                        } else { // 1-bit</span>
<span class="fc" id="L577">                            MultiPixelPackedSampleModel mpp =</span>
<span class="fc" id="L578">                                (MultiPixelPackedSampleModel)src.getSampleModel();</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">                            if (mpp.getNumBands() == 1</span>
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">                               &amp;&amp; mpp.getDataBitOffset() == 0</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">                               &amp;&amp; mpp.getPixelBitStride() == 1) {</span>
<span class="fc" id="L582">                                useDataBuffer = true;</span>
                            }
                        }
                    }

<span class="pc bpc" id="L587" title="1 of 2 branches missed.">                    if (!useDataBuffer) {</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">                        if (dataType == DataBuffer.TYPE_FLOAT) {</span>
<span class="nc" id="L589">                            fpixels = src.getPixels(col, row, tileWidth, rows,</span>
                                                    fpixels);
                        } else {
<span class="nc" id="L592">                            pixels = src.getPixels(col, row, tileWidth, rows,</span>
                                                   pixels);
                        }
                    }
                }

                int index;

<span class="fc" id="L600">                int pixel = 0;</span>
<span class="fc" id="L601">                int k = 0;</span>
<span class="pc bpc" id="L602" title="4 of 6 branches missed.">                switch (dataTypeSize) {</span>

                case 1:

<span class="pc bpc" id="L606" title="1 of 2 branches missed.">                    if (useDataBuffer) {</span>
<span class="fc" id="L607">                        byte[] btmp =</span>
<span class="fc" id="L608">                            ((DataBufferByte)src.getDataBuffer()).getData();</span>
<span class="fc" id="L609">                        MultiPixelPackedSampleModel mpp =</span>
<span class="fc" id="L610">                            (MultiPixelPackedSampleModel)src.getSampleModel();</span>
<span class="fc" id="L611">                        int lineStride = mpp.getScanlineStride();</span>
<span class="fc" id="L612">                        int inOffset =</span>
<span class="fc" id="L613">                            mpp.getOffset(col</span>
<span class="fc" id="L614">                                          - src.getSampleModelTranslateX(),</span>
                                          row
<span class="fc" id="L616">                                          - src.getSampleModelTranslateY());</span>
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">                        if (lineStride == bytesPerRow) {</span>
<span class="fc" id="L618">                            System.arraycopy(btmp, inOffset,</span>
                                             bpixels, 0,
                                             (int) bytesPerRow * rows);
                        } else {
<span class="nc" id="L622">                            int outOffset = 0;</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">                            for (int j = 0; j &lt; rows; j++) {</span>
<span class="nc" id="L624">                                System.arraycopy(btmp, inOffset,</span>
                                                 bpixels, outOffset,
                                                 (int) bytesPerRow);
<span class="nc" id="L627">                                inOffset += lineStride;</span>
<span class="nc" id="L628">                                outOffset += bytesPerRow;</span>
                            }
                        }
<span class="fc" id="L631">                    } else {</span>
<span class="nc" id="L632">                        index = 0;</span>

                        // For each of the rows in a strip
<span class="nc bnc" id="L635" title="All 2 branches missed.">                        for (int i = 0; i &lt; rows; i++) {</span>

                            // Write number of pixels exactly divisible by 8
<span class="nc bnc" id="L638" title="All 2 branches missed.">                            for (int j = 0; j &lt; tileWidth / 8; j++) {</span>

<span class="nc" id="L640">                                pixel =</span>
                                    (pixels[index++] &lt;&lt; 7)
                                    | (pixels[index++] &lt;&lt; 6)
                                    | (pixels[index++] &lt;&lt; 5)
                                    | (pixels[index++] &lt;&lt; 4)
                                    | (pixels[index++] &lt;&lt; 3)
                                    | (pixels[index++] &lt;&lt; 2)
                                    | (pixels[index++] &lt;&lt; 1)
                                    | pixels[index++];
<span class="nc" id="L649">                                bpixels[k++] = (byte)pixel;</span>
                            }

                            // Write the pixels remaining after division by 8
<span class="nc bnc" id="L653" title="All 2 branches missed.">                            if (tileWidth % 8 &gt; 0) {</span>
<span class="nc" id="L654">                                pixel = 0;</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">                                for (int j = 0; j &lt; tileWidth % 8; j++) {</span>
<span class="nc" id="L656">                                    pixel |= (pixels[index++] &lt;&lt; (7 - j));</span>
                                }
<span class="nc" id="L658">                                bpixels[k++] = (byte)pixel;</span>
                            }
                        }
                    }

<span class="pc bpc" id="L663" title="1 of 2 branches missed.">                    if (compression == CompressionValue.NONE) {</span>
<span class="fc" id="L664">                        output.write(bpixels, 0, rows * ((tileWidth + 7) / 8));</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">                    } else if (compression == CompressionValue.PACKBITS) {</span>
<span class="nc" id="L666">                        int numCompressedBytes =</span>
<span class="nc" id="L667">                            compressPackBits(bpixels, rows,</span>
                                             bytesPerRow,
                                             compressBuf);
<span class="nc" id="L670">                        tileByteCounts[tileNum++] = numCompressedBytes;</span>
<span class="nc" id="L671">                        output.write(compressBuf, 0, numCompressedBytes);</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">                    } else if (compression == CompressionValue.DEFLATE) {</span>
<span class="nc" id="L673">                        int numCompressedBytes =</span>
<span class="nc" id="L674">                            deflate(deflater, bpixels, compressBuf);</span>
<span class="nc" id="L675">                        tileByteCounts[tileNum++] = numCompressedBytes;</span>
<span class="nc" id="L676">                        output.write(compressBuf, 0, numCompressedBytes);</span>
<span class="nc" id="L677">                    }</span>

                    break;

                case 4:

<span class="nc" id="L683">                    index = 0;</span>

                    // For each of the rows in a strip
<span class="nc bnc" id="L686" title="All 2 branches missed.">                    for (int i = 0; i &lt; rows; i++) {</span>

                        // Write  the number of pixels that will fit into an
                        // even number of nibbles.
<span class="nc bnc" id="L690" title="All 2 branches missed.">                        for (int j = 0; j &lt; tileWidth / 2; j++) {</span>
<span class="nc" id="L691">                            pixel = (pixels[index++] &lt;&lt; 4) | pixels[index++];</span>
<span class="nc" id="L692">                            bpixels[k++] = (byte)pixel;</span>
                        }

                        // Last pixel for odd-length lines
<span class="nc bnc" id="L696" title="All 2 branches missed.">                        if ((tileWidth &amp; 1) == 1) {</span>
<span class="nc" id="L697">                            pixel = pixels[index++] &lt;&lt; 4;</span>
<span class="nc" id="L698">                            bpixels[k++] = (byte)pixel;</span>
                        }
                    }

<span class="nc bnc" id="L702" title="All 2 branches missed.">                    if (compression == CompressionValue.NONE) {</span>
<span class="nc" id="L703">                        output.write(bpixels, 0, rows * ((tileWidth + 1) / 2));</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">                    } else if (compression == CompressionValue.PACKBITS) {</span>
<span class="nc" id="L705">                        int numCompressedBytes =</span>
<span class="nc" id="L706">                            compressPackBits(bpixels, rows,</span>
                                             bytesPerRow,
                                             compressBuf);
<span class="nc" id="L709">                        tileByteCounts[tileNum++] = numCompressedBytes;</span>
<span class="nc" id="L710">                        output.write(compressBuf, 0, numCompressedBytes);</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">                    } else if (compression == CompressionValue.DEFLATE) {</span>
<span class="nc" id="L712">                        int numCompressedBytes =</span>
<span class="nc" id="L713">                            deflate(deflater, bpixels, compressBuf);</span>
<span class="nc" id="L714">                        tileByteCounts[tileNum++] = numCompressedBytes;</span>
<span class="nc" id="L715">                        output.write(compressBuf, 0, numCompressedBytes);</span>
<span class="nc" id="L716">                    }</span>
                    break;

                case 8:

<span class="pc bpc" id="L721" title="1 of 2 branches missed.">                    if (compression != CompressionValue.JPEG_TTN2) {</span>
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">                        if (useDataBuffer) {</span>
<span class="fc" id="L723">                            byte[] btmp =</span>
<span class="fc" id="L724">                                ((DataBufferByte)src.getDataBuffer()).getData();</span>
<span class="fc" id="L725">                            ComponentSampleModel csm =</span>
<span class="fc" id="L726">                                (ComponentSampleModel)src.getSampleModel();</span>
<span class="fc" id="L727">                            int inOffset =</span>
<span class="fc" id="L728">                                csm.getOffset(col</span>
<span class="fc" id="L729">                                              - src.getSampleModelTranslateX(),</span>
                                              row
<span class="fc" id="L731">                                              - src.getSampleModelTranslateY());</span>
<span class="fc" id="L732">                            int lineStride = csm.getScanlineStride();</span>
<span class="pc bpc" id="L733" title="1 of 2 branches missed.">                            if (lineStride == bytesPerRow) {</span>
<span class="fc" id="L734">                                System.arraycopy(btmp,</span>
                                                 inOffset,
                                                 bpixels, 0,
                                                 (int) bytesPerRow * rows);
                            } else {
<span class="nc" id="L739">                                int outOffset = 0;</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">                                for (int j = 0; j &lt; rows; j++) {</span>
<span class="nc" id="L741">                                    System.arraycopy(btmp, inOffset,</span>
                                                     bpixels, outOffset,
                                                     (int) bytesPerRow);
<span class="nc" id="L744">                                    inOffset += lineStride;</span>
<span class="nc" id="L745">                                    outOffset += bytesPerRow;</span>
                                }
                            }
<span class="fc" id="L748">                        } else {</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">                            for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L750">                                bpixels[i] = (byte)pixels[i];</span>
                            }
                        }
                    }

<span class="pc bpc" id="L755" title="1 of 2 branches missed.">                    if (compression == CompressionValue.NONE) {</span>
<span class="fc" id="L756">                        output.write(bpixels, 0, size);</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">                    } else if (compression == CompressionValue.PACKBITS) {</span>
<span class="nc" id="L758">                        int numCompressedBytes =</span>
<span class="nc" id="L759">                            compressPackBits(bpixels, rows,</span>
                                             bytesPerRow,
                                             compressBuf);
<span class="nc" id="L762">                        tileByteCounts[tileNum++] = numCompressedBytes;</span>
<span class="nc" id="L763">                        output.write(compressBuf, 0, numCompressedBytes);</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">                    } else if (compression == CompressionValue.DEFLATE) {</span>
<span class="nc" id="L765">                        int numCompressedBytes =</span>
<span class="nc" id="L766">                            deflate(deflater, bpixels, compressBuf);</span>
<span class="nc" id="L767">                        tileByteCounts[tileNum++] = numCompressedBytes;</span>
<span class="nc" id="L768">                        output.write(compressBuf, 0, numCompressedBytes);</span>
<span class="nc" id="L769">                    }</span>
                    break;

                case 16:

<span class="nc" id="L774">                    int ls = 0;</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">                    for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L776">                        int value = pixels[i];</span>
<span class="nc" id="L777">                        bpixels[ls++] = (byte)((value &amp; 0xff00) &gt;&gt; 8);</span>
<span class="nc" id="L778">                        bpixels[ls++] = (byte) (value &amp; 0x00ff);</span>
                    }

<span class="nc bnc" id="L781" title="All 2 branches missed.">                    if (compression == CompressionValue.NONE) {</span>
<span class="nc" id="L782">                        output.write(bpixels, 0, size * 2);</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">                    } else if (compression == CompressionValue.PACKBITS) {</span>
<span class="nc" id="L784">                        int numCompressedBytes =</span>
<span class="nc" id="L785">                            compressPackBits(bpixels, rows,</span>
                                             bytesPerRow,
                                             compressBuf);
<span class="nc" id="L788">                        tileByteCounts[tileNum++] = numCompressedBytes;</span>
<span class="nc" id="L789">                        output.write(compressBuf, 0, numCompressedBytes);</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">                    } else if (compression == CompressionValue.DEFLATE) {</span>
<span class="nc" id="L791">                        int numCompressedBytes =</span>
<span class="nc" id="L792">                            deflate(deflater, bpixels, compressBuf);</span>
<span class="nc" id="L793">                        tileByteCounts[tileNum++] = numCompressedBytes;</span>
<span class="nc" id="L794">                        output.write(compressBuf, 0, numCompressedBytes);</span>
<span class="nc" id="L795">                    }</span>
                    break;

                case 32:
<span class="nc bnc" id="L799" title="All 2 branches missed.">                    if (dataType == DataBuffer.TYPE_INT) {</span>
<span class="nc" id="L800">                        int li = 0;</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">                        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L802">                            int value = pixels[i];</span>
<span class="nc" id="L803">                            bpixels[li++] = (byte)((value &amp; 0xff000000) &gt;&gt;&gt; 24);</span>
<span class="nc" id="L804">                            bpixels[li++] = (byte)((value &amp; 0x00ff0000) &gt;&gt;&gt; 16);</span>
<span class="nc" id="L805">                            bpixels[li++] = (byte)((value &amp; 0x0000ff00) &gt;&gt;&gt; 8);</span>
<span class="nc" id="L806">                            bpixels[li++] = (byte)(value &amp; 0x000000ff);</span>
                        }
<span class="nc" id="L808">                    } else { // DataBuffer.TYPE_FLOAT</span>
<span class="nc" id="L809">                        int lf = 0;</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">                        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L811">                            int value = Float.floatToIntBits(fpixels[i]);</span>
<span class="nc" id="L812">                            bpixels[lf++] = (byte)((value &amp; 0xff000000) &gt;&gt;&gt; 24);</span>
<span class="nc" id="L813">                            bpixels[lf++] = (byte)((value &amp; 0x00ff0000) &gt;&gt;&gt; 16);</span>
<span class="nc" id="L814">                            bpixels[lf++] = (byte)((value &amp; 0x0000ff00) &gt;&gt;&gt; 8);</span>
<span class="nc" id="L815">                            bpixels[lf++] = (byte)(value &amp; 0x000000ff);</span>
                        }
                    }
<span class="nc bnc" id="L818" title="All 2 branches missed.">                    if (compression == CompressionValue.NONE) {</span>
<span class="nc" id="L819">                        output.write(bpixels, 0, size * 4);</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">                    } else if (compression == CompressionValue.PACKBITS) {</span>
<span class="nc" id="L821">                        int numCompressedBytes =</span>
<span class="nc" id="L822">                            compressPackBits(bpixels, rows,</span>
                                             bytesPerRow,
                                             compressBuf);
<span class="nc" id="L825">                        tileByteCounts[tileNum++] = numCompressedBytes;</span>
<span class="nc" id="L826">                        output.write(compressBuf, 0, numCompressedBytes);</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">                    } else if (compression == CompressionValue.DEFLATE) {</span>
<span class="nc" id="L828">                        int numCompressedBytes =</span>
<span class="nc" id="L829">                            deflate(deflater, bpixels, compressBuf);</span>
<span class="nc" id="L830">                        tileByteCounts[tileNum++] = numCompressedBytes;</span>
<span class="nc" id="L831">                        output.write(compressBuf, 0, numCompressedBytes);</span>
<span class="nc" id="L832">                    }</span>
                    break;
                default:
                    break;
                }
            }
        }

<span class="pc bpc" id="L840" title="1 of 2 branches missed.">        if (compression == CompressionValue.NONE) {</span>
            // Write an extra byte for IFD word alignment if needed.
<span class="pc bpc" id="L842" title="1 of 2 branches missed.">            if (skipByte) {</span>
<span class="nc" id="L843">                output.write((byte)0);</span>
            }
        } else {
            // Recompute the tile offsets the size of the compressed tiles.
<span class="nc" id="L847">            int totalBytes = 0;</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">            for (int i = 1; i &lt; numTiles; i++) {</span>
<span class="nc" id="L849">                int numBytes = (int)tileByteCounts[i - 1];</span>
<span class="nc" id="L850">                totalBytes += numBytes;</span>
<span class="nc" id="L851">                tileOffsets[i] = tileOffsets[i - 1] + numBytes;</span>
            }
<span class="nc" id="L853">            totalBytes += (int)tileByteCounts[numTiles - 1];</span>

<span class="nc bnc" id="L855" title="All 2 branches missed.">            nextIFDOffset = isLast</span>
<span class="nc" id="L856">                ? 0 : ifdOffset + dirSize + totalBytes;</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">            if ((nextIFDOffset &amp; 0x01) != 0) {   // make it even</span>
<span class="nc" id="L858">                nextIFDOffset++;</span>
<span class="nc" id="L859">                skipByte = true;</span>
            }

<span class="nc bnc" id="L862" title="All 2 branches missed.">            if (outCache == null) {</span>
                // Original OutputStream must be a SeekableOutputStream.

                // Write an extra byte for IFD word alignment if needed.
<span class="nc bnc" id="L866" title="All 2 branches missed.">                if (skipByte) {</span>
<span class="nc" id="L867">                    output.write((byte)0);</span>
                }

<span class="nc" id="L870">                SeekableOutputStream sos = (SeekableOutputStream)output;</span>

                // Save current position.
<span class="nc" id="L873">                long savePos = sos.getFilePointer();</span>

                // Seek backward to the IFD offset and write IFD.
<span class="nc" id="L876">                sos.seek(ifdOffset);</span>
<span class="nc" id="L877">                writeDirectory(ifdOffset, fields, nextIFDOffset);</span>

                // Seek forward to position after data.
<span class="nc" id="L880">                sos.seek(savePos);</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">            } else if (tempFile != null) {</span>

                // Using a file cache for the image data.

                // Open a FileInputStream from which to copy the data.
<span class="nc" id="L886">                FileInputStream fileStream = new FileInputStream(tempFile);</span>
                try {
                    // Close the original SeekableOutputStream.
<span class="nc" id="L889">                    output.close();</span>

                    // Reset variable to the original OutputStream.
<span class="nc" id="L892">                    output = outCache;</span>

                    // Write the IFD.
<span class="nc" id="L895">                    writeDirectory(ifdOffset, fields, nextIFDOffset);</span>

                    // Write the image data.
<span class="nc" id="L898">                    byte[] copyBuffer = new byte[8192];</span>
<span class="nc" id="L899">                    int bytesCopied = 0;</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">                    while (bytesCopied &lt; totalBytes) {</span>
<span class="nc" id="L901">                        int bytesRead = fileStream.read(copyBuffer);</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">                        if (bytesRead == -1) {</span>
<span class="nc" id="L903">                            break;</span>
                        }
<span class="nc" id="L905">                        output.write(copyBuffer, 0, bytesRead);</span>
<span class="nc" id="L906">                        bytesCopied += bytesRead;</span>
<span class="nc" id="L907">                    }</span>
                } finally {
                    // Delete the temporary file.
<span class="nc" id="L910">                    fileStream.close();</span>
                }
<span class="nc" id="L912">                boolean isDeleted = tempFile.delete();</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">                assert isDeleted;</span>

                // Write an extra byte for IFD word alignment if needed.
<span class="nc bnc" id="L916" title="All 2 branches missed.">                if (skipByte) {</span>
<span class="nc" id="L917">                    output.write((byte)0);</span>
                }
<span class="nc bnc" id="L919" title="All 2 branches missed.">            } else if (output instanceof ByteArrayOutputStream) {</span>

                // Using a memory cache for the image data.

<span class="nc" id="L923">                ByteArrayOutputStream memoryStream = (ByteArrayOutputStream)output;</span>

                // Reset variable to the original OutputStream.
<span class="nc" id="L926">                output = outCache;</span>

                // Write the IFD.
<span class="nc" id="L929">                writeDirectory(ifdOffset, fields, nextIFDOffset);</span>

                // Write the image data.
<span class="nc" id="L932">                memoryStream.writeTo(output);</span>

                // Write an extra byte for IFD word alignment if needed.
<span class="nc bnc" id="L935" title="All 2 branches missed.">                if (skipByte) {</span>
<span class="nc" id="L936">                    output.write((byte)0);</span>
                }
<span class="nc" id="L938">            } else {</span>
                // This should never happen.
<span class="nc" id="L940">                throw new IllegalStateException(PropertyUtil.getString(&quot;TIFFImageEncoder13&quot;));</span>
            }
        }


<span class="fc" id="L945">        return nextIFDOffset;</span>
    }

    private void validateImage(int dataTypeSize, int[] sampleSize, int numBands, int dataType,
            ColorModel colorModel) {
        // Retrieve and verify sample size.
<span class="pc bpc" id="L951" title="1 of 2 branches missed.">        for (int i = 1; i &lt; sampleSize.length; i++) {</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">            if (sampleSize[i] != dataTypeSize) {</span>
<span class="nc" id="L953">                throw new RuntimeException(PropertyUtil.getString(&quot;TIFFImageEncoder0&quot;));</span>
            }
        }

        // Check low bit limits.
<span class="pc bpc" id="L958" title="2 of 6 branches missed.">        if ((dataTypeSize == 1 || dataTypeSize == 4) &amp;&amp; numBands != 1) {</span>
<span class="nc" id="L959">            throw new RuntimeException(PropertyUtil.getString(&quot;TIFFImageEncoder1&quot;));</span>
        }

        // Retrieve and verify data type.
<span class="pc bpc" id="L963" title="3 of 4 branches missed.">        switch (dataType) {</span>
        case DataBuffer.TYPE_BYTE:
<span class="pc bpc" id="L965" title="1 of 2 branches missed.">            if (dataTypeSize == 4) {</span>
<span class="nc" id="L966">                throw new RuntimeException(PropertyUtil.getString(&quot;TIFFImageEncoder2&quot;));</span>
            }
            break;
        case DataBuffer.TYPE_SHORT:
        case DataBuffer.TYPE_USHORT:
<span class="nc bnc" id="L971" title="All 2 branches missed.">            if (dataTypeSize != 16) {</span>
<span class="nc" id="L972">                throw new RuntimeException(PropertyUtil.getString(&quot;TIFFImageEncoder3&quot;));</span>
            }
            break;
        case DataBuffer.TYPE_INT:
        case DataBuffer.TYPE_FLOAT:
<span class="nc bnc" id="L977" title="All 2 branches missed.">            if (dataTypeSize != 32) {</span>
<span class="nc" id="L978">                throw new RuntimeException(PropertyUtil.getString(&quot;TIFFImageEncoder4&quot;));</span>
            }
            break;
        default:
<span class="nc" id="L982">            throw new RuntimeException(PropertyUtil.getString(&quot;TIFFImageEncoder5&quot;));</span>
        }

<span class="pc bpc" id="L985" title="1 of 4 branches missed.">        if (colorModel instanceof IndexColorModel &amp;&amp; dataType != DataBuffer.TYPE_BYTE) {</span>
            // Don't support (unsigned) short palette-color images.
<span class="nc" id="L987">            throw new RuntimeException(PropertyUtil.getString(&quot;TIFFImageEncoder6&quot;));</span>
        }
<span class="fc" id="L989">    }</span>

    /**
     * Calculates the size of the IFD.
     */
    private int getDirectorySize(SortedSet fields) {
        // Get the number of entries.
<span class="fc" id="L996">        int numEntries = fields.size();</span>

        // Initialize the size excluding that of any values &gt; 4 bytes.
<span class="fc" id="L999">        int dirSize = 2 + numEntries * 12 + 4;</span>

        // Loop over fields adding the size of all values &gt; 4 bytes.
<span class="fc bfc" id="L1002" title="All 2 branches covered.">        for (Object field1 : fields) {</span>
            // Get the field.
<span class="fc" id="L1004">            TIFFField field = (TIFFField) field1;</span>

            // Determine the size of the field value.
<span class="fc" id="L1007">            int valueSize = field.getCount() * SIZE_OF_TYPE[field.getType()];</span>

            // Add any excess size.
<span class="fc bfc" id="L1010" title="All 2 branches covered.">            if (valueSize &gt; 4) {</span>
<span class="fc" id="L1011">                dirSize += valueSize;</span>
            }
<span class="fc" id="L1013">        }</span>

<span class="fc" id="L1015">        return dirSize;</span>
    }

    private void writeFileHeader() throws IOException {
        // 8 byte image file header

        // Byte order used within the file - Big Endian
<span class="fc" id="L1022">        output.write('M');</span>
<span class="fc" id="L1023">        output.write('M');</span>

        // Magic value
<span class="fc" id="L1026">        output.write(0);</span>
<span class="fc" id="L1027">        output.write(42);</span>

        // Offset in bytes of the first IFD.
<span class="fc" id="L1030">        writeLong(8);</span>
<span class="fc" id="L1031">    }</span>

    private void writeDirectory(int thisIFDOffset, SortedSet fields,
                                int nextIFDOffset)
        throws IOException {

        // 2 byte count of number of directory entries (fields)
<span class="fc" id="L1038">        int numEntries = fields.size();</span>

<span class="fc" id="L1040">        long offsetBeyondIFD = thisIFDOffset + 12 * numEntries + 4 + 2;</span>
<span class="fc" id="L1041">        List tooBig = new ArrayList();</span>

        // Write number of fields in the IFD
<span class="fc" id="L1044">        writeUnsignedShort(numEntries);</span>

<span class="fc bfc" id="L1046" title="All 2 branches covered.">        for (Object field1 : fields) {</span>

            // 12 byte field entry TIFFField
<span class="fc" id="L1049">            TIFFField field = (TIFFField) field1;</span>

            // byte 0-1 Tag that identifies a field
<span class="fc" id="L1052">            int tag = field.getTag();</span>
<span class="fc" id="L1053">            writeUnsignedShort(tag);</span>

            // byte 2-3 The field type
<span class="fc" id="L1056">            int type = field.getType();</span>
<span class="fc" id="L1057">            writeUnsignedShort(type);</span>

            // bytes 4-7 the number of values of the indicated type except
            // ASCII-valued fields which require the total number of bytes.
<span class="fc" id="L1061">            int count = field.getCount();</span>
<span class="fc" id="L1062">            int valueSize = getValueSize(field);</span>
<span class="pc bpc" id="L1063" title="1 of 2 branches missed.">            writeLong(type == TIFFField.TIFF_ASCII ? valueSize : count);</span>

            // bytes 8 - 11 the value or value offset
<span class="fc bfc" id="L1066" title="All 2 branches covered.">            if (valueSize &gt; 4) {</span>

                // We need an offset as data won't fit into 4 bytes
<span class="fc" id="L1069">                writeLong(offsetBeyondIFD);</span>
<span class="fc" id="L1070">                offsetBeyondIFD += valueSize;</span>
<span class="fc" id="L1071">                tooBig.add(field);</span>

            } else {
<span class="fc" id="L1074">                writeValuesAsFourBytes(field);</span>
            }

<span class="fc" id="L1077">        }</span>

        // Address of next IFD
<span class="fc" id="L1080">        writeLong(nextIFDOffset);</span>

        // Write the tag values that did not fit into 4 bytes
<span class="fc bfc" id="L1083" title="All 2 branches covered.">        for (Object aTooBig : tooBig) {</span>
<span class="fc" id="L1084">            writeValues((TIFFField) aTooBig);</span>
<span class="fc" id="L1085">        }</span>
<span class="fc" id="L1086">    }</span>

    /**
     * Determine the number of bytes in the value portion of the field.
     */
    private static int getValueSize(TIFFField field) throws UnsupportedEncodingException {
<span class="fc" id="L1092">        int type = field.getType();</span>
<span class="fc" id="L1093">        int count = field.getCount();</span>
<span class="fc" id="L1094">        int valueSize = 0;</span>
<span class="pc bpc" id="L1095" title="1 of 2 branches missed.">        if (type == TIFFField.TIFF_ASCII) {</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1097">                byte[] stringBytes = field.getAsString(i).getBytes(&quot;UTF-8&quot;);   // note: default encoding @work here!</span>
<span class="nc" id="L1098">                valueSize += stringBytes.length;</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">                if (stringBytes[stringBytes.length - 1] != 0) {</span>
<span class="nc" id="L1100">                    valueSize++;</span>
                }
            }
        } else {
<span class="fc" id="L1104">            valueSize = count * SIZE_OF_TYPE[type];</span>
        }
<span class="fc" id="L1106">        return valueSize;</span>
    }

<span class="fc" id="L1109">    private static final int[] SIZE_OF_TYPE = {</span>
        0, //  0 = n/a
        1, //  1 = byte
        1, //  2 = ascii
        2, //  3 = short
        4, //  4 = long
        8, //  5 = rational
        1, //  6 = sbyte
        1, //  7 = undefined
        2, //  8 = sshort
        4, //  9 = slong
        8, // 10 = srational
        4, // 11 = float
        8  // 12 = double
    };

    private void writeValuesAsFourBytes(TIFFField field) throws IOException {

<span class="fc" id="L1127">        int dataType = field.getType();</span>
<span class="fc" id="L1128">        int count = field.getCount();</span>

<span class="pc bpc" id="L1130" title="2 of 4 branches missed.">        switch (dataType) {</span>

            // unsigned 8 bits
        case TIFFField.TIFF_BYTE:
<span class="nc" id="L1134">            byte[] bytes = field.getAsBytes();</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">            if (count &gt; 4) {</span>
<span class="nc" id="L1136">                count = 4;</span>
            }
<span class="nc bnc" id="L1138" title="All 2 branches missed.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1139">                output.write(bytes[i]);</span>
            }

<span class="nc bnc" id="L1142" title="All 2 branches missed.">            for (int i = 0; i &lt; (4 - count); i++) {</span>
<span class="nc" id="L1143">                output.write(0);</span>
            }
<span class="nc" id="L1145">            break;</span>

            // unsigned 16 bits
        case TIFFField.TIFF_SHORT:
<span class="fc" id="L1149">            char[] chars = field.getAsChars();</span>
<span class="pc bpc" id="L1150" title="1 of 2 branches missed.">            if (count &gt; 2) {</span>
<span class="nc" id="L1151">                count = 2;</span>
            }
<span class="fc bfc" id="L1153" title="All 2 branches covered.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L1154">                writeUnsignedShort(chars[i]);</span>
            }
<span class="fc bfc" id="L1156" title="All 2 branches covered.">            for (int i = 0; i &lt; (2 - count); i++) {</span>
<span class="fc" id="L1157">                writeUnsignedShort(0);</span>
            }

<span class="fc" id="L1160">            break;</span>

            // unsigned 32 bits
        case TIFFField.TIFF_LONG:
<span class="fc" id="L1164">            long[] longs = field.getAsLongs();</span>

<span class="fc bfc" id="L1166" title="All 2 branches covered.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L1167">                writeLong(longs[i]);</span>
            }
            break;
        }

<span class="fc" id="L1172">    }</span>

    private void writeValues(TIFFField field) throws IOException {

<span class="fc" id="L1176">        int dataType = field.getType();</span>
<span class="fc" id="L1177">        int count = field.getCount();</span>

<span class="pc bpc" id="L1179" title="8 of 9 branches missed.">        switch (dataType) {</span>

            // unsigned 8 bits
        case TIFFField.TIFF_BYTE:
        case TIFFField.TIFF_SBYTE:
        case TIFFField.TIFF_UNDEFINED:
<span class="nc" id="L1185">            byte[] bytes = field.getAsBytes();</span>
<span class="nc bnc" id="L1186" title="All 2 branches missed.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1187">                output.write(bytes[i]);</span>
            }
<span class="nc" id="L1189">            break;</span>

            // unsigned 16 bits
        case TIFFField.TIFF_SHORT:
<span class="nc" id="L1193">            char[] chars = field.getAsChars();</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1195">                writeUnsignedShort(chars[i]);</span>
            }
<span class="nc" id="L1197">            break;</span>
        case TIFFField.TIFF_SSHORT:
<span class="nc" id="L1199">            short[] shorts = field.getAsShorts();</span>
<span class="nc bnc" id="L1200" title="All 2 branches missed.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1201">                writeUnsignedShort(shorts[i]);</span>
            }
<span class="nc" id="L1203">            break;</span>

            // unsigned 32 bits
        case TIFFField.TIFF_LONG:
        case TIFFField.TIFF_SLONG:
<span class="fc" id="L1208">            long[] longs = field.getAsLongs();</span>
<span class="fc bfc" id="L1209" title="All 2 branches covered.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L1210">                writeLong(longs[i]);</span>
            }
<span class="fc" id="L1212">            break;</span>

        case TIFFField.TIFF_FLOAT:
<span class="nc" id="L1215">            float[] floats = field.getAsFloats();</span>
<span class="nc bnc" id="L1216" title="All 2 branches missed.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1217">                int intBits = Float.floatToIntBits(floats[i]);</span>
<span class="nc" id="L1218">                writeLong(intBits);</span>
            }
<span class="nc" id="L1220">            break;</span>

        case TIFFField.TIFF_DOUBLE:
<span class="nc" id="L1223">            double[] doubles = field.getAsDoubles();</span>
<span class="nc bnc" id="L1224" title="All 2 branches missed.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1225">                long longBits = Double.doubleToLongBits(doubles[i]);</span>
<span class="nc" id="L1226">                writeLong(longBits &gt;&gt;&gt; 32);           // write upper 32 bits</span>
<span class="nc" id="L1227">                writeLong(longBits &amp; 0xffffffffL);    // write lower 32 bits</span>
            }
<span class="nc" id="L1229">            break;</span>

        case TIFFField.TIFF_RATIONAL:
        case TIFFField.TIFF_SRATIONAL:
<span class="nc" id="L1233">            long[][] rationals = field.getAsRationals();</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1235">                writeLong(rationals[i][0]);</span>
<span class="nc" id="L1236">                writeLong(rationals[i][1]);</span>
            }
<span class="nc" id="L1238">            break;</span>

        case TIFFField.TIFF_ASCII:
<span class="nc bnc" id="L1241" title="All 2 branches missed.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1242">                byte[] stringBytes = field.getAsString(i).getBytes(&quot;UTF-8&quot;);</span>
<span class="nc" id="L1243">                output.write(stringBytes);</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">                if (stringBytes[stringBytes.length - 1] != (byte)0) {</span>
<span class="nc" id="L1245">                    output.write((byte)0);</span>
                }
            }
<span class="nc" id="L1248">            break;</span>

        default:
<span class="nc" id="L1251">            throw new RuntimeException(PropertyUtil.getString(&quot;TIFFImageEncoder10&quot;));</span>

        }

<span class="fc" id="L1255">    }</span>

    // Here s is never expected to have value greater than what can be
    // stored in 2 bytes.
    private void writeUnsignedShort(int s) throws IOException {
<span class="fc" id="L1260">        output.write((s &amp; 0xff00) &gt;&gt;&gt; 8);</span>
<span class="fc" id="L1261">        output.write(s &amp; 0x00ff);</span>
<span class="fc" id="L1262">    }</span>

    /**
     * despite its name, this method writes only 4 bytes to output.
     * @param l 32bits of this are written as 4 bytes
     * @throws IOException
     */
    private void writeLong(long l) throws IOException {
<span class="fc" id="L1270">        output.write((int)((l &amp; 0xff000000) &gt;&gt;&gt; 24));</span>
<span class="fc" id="L1271">        output.write((int)((l &amp; 0x00ff0000) &gt;&gt;&gt; 16));</span>
<span class="fc" id="L1272">        output.write((int)((l &amp; 0x0000ff00) &gt;&gt;&gt; 8));</span>
<span class="fc" id="L1273">        output.write((int) (l &amp; 0x000000ff));</span>
<span class="fc" id="L1274">    }</span>

//    /**
//     * Returns the current offset in the supplied OutputStream.
//     * This method should only be used if compressing data.
//     */
//    private long getOffset(OutputStream out) throws IOException {
//        if (out instanceof ByteArrayOutputStream) {
//            return ((ByteArrayOutputStream)out).size();
//        } else if (out instanceof SeekableOutputStream) {
//            return ((SeekableOutputStream)out).getFilePointer();
//        } else {
//            // Shouldn't happen.
//            throw new IllegalStateException(PropertyUtil.getString(&quot;TIFFImageEncoder13&quot;));
//        }
//    }

    /**
     * Performs PackBits compression on a tile of data.
     */
    private static int compressPackBits(byte[] data, int numRows,
                                        long bytesPerRow, byte[] compData) {
<span class="nc" id="L1296">        int inOffset = 0;</span>
<span class="nc" id="L1297">        int outOffset = 0;</span>

<span class="nc bnc" id="L1299" title="All 2 branches missed.">        for (int i = 0; i &lt; numRows; i++) {</span>
<span class="nc" id="L1300">            outOffset = packBits(data, inOffset, (int) bytesPerRow,</span>
                                 compData, outOffset);
<span class="nc" id="L1302">            inOffset += bytesPerRow;</span>
        }

<span class="nc" id="L1305">        return outOffset;</span>
    }

    /**
     * Performs PackBits compression for a single buffer of data.
     * This should be called for each row of each tile. The returned
     * value is the offset into the output buffer after compression.
     */
    private static int packBits(byte[] input, int inOffset, int inCount,
                                byte[] output, int outOffset) {
<span class="nc" id="L1315">        int inMax = inOffset + inCount - 1;</span>
<span class="nc" id="L1316">        int inMaxMinus1 = inMax - 1;</span>

<span class="nc bnc" id="L1318" title="All 2 branches missed.">        while (inOffset &lt;= inMax) {</span>
<span class="nc" id="L1319">            int run = 1;</span>
<span class="nc" id="L1320">            byte replicate = input[inOffset];</span>
<span class="nc bnc" id="L1321" title="All 6 branches missed.">            while (run &lt; 127 &amp;&amp; inOffset &lt; inMax</span>
                  &amp;&amp; input[inOffset] == input[inOffset + 1]) {
<span class="nc" id="L1323">                run++;</span>
<span class="nc" id="L1324">                inOffset++;</span>
            }
<span class="nc bnc" id="L1326" title="All 2 branches missed.">            if (run &gt; 1) {</span>
<span class="nc" id="L1327">                inOffset++;</span>
<span class="nc" id="L1328">                output[outOffset++] = (byte)(-(run - 1));</span>
<span class="nc" id="L1329">                output[outOffset++] = replicate;</span>
            }

<span class="nc" id="L1332">            run = 0;</span>
<span class="nc" id="L1333">            int saveOffset = outOffset;</span>
<span class="nc bnc" id="L1334" title="All 10 branches missed.">            while (run &lt; 128</span>
                  &amp;&amp; ((inOffset &lt; inMax
                    &amp;&amp; input[inOffset] != input[inOffset + 1])
                   || (inOffset &lt; inMaxMinus1
                    &amp;&amp; input[inOffset] != input[inOffset + 2]))) {
<span class="nc" id="L1339">                run++;</span>
<span class="nc" id="L1340">                output[++outOffset] = input[inOffset++];</span>
            }
<span class="nc bnc" id="L1342" title="All 2 branches missed.">            if (run &gt; 0) {</span>
<span class="nc" id="L1343">                output[saveOffset] = (byte)(run - 1);</span>
<span class="nc" id="L1344">                outOffset++;</span>
            }

<span class="nc bnc" id="L1347" title="All 2 branches missed.">            if (inOffset == inMax) {</span>
<span class="nc bnc" id="L1348" title="All 4 branches missed.">                if (run &gt; 0 &amp;&amp; run &lt; 128) {</span>
<span class="nc" id="L1349">                    output[saveOffset]++;</span>
<span class="nc" id="L1350">                    output[outOffset++] = input[inOffset++];</span>
                } else {
<span class="nc" id="L1352">                    output[outOffset++] = (byte)0;</span>
<span class="nc" id="L1353">                    output[outOffset++] = input[inOffset++];</span>
                }
            }
<span class="nc" id="L1356">        }</span>

<span class="nc" id="L1358">        return outOffset;</span>
    }

    private static int deflate(Deflater deflater,
                               byte[] inflated, byte[] deflated) {
<span class="nc" id="L1363">        deflater.setInput(inflated);</span>
<span class="nc" id="L1364">        deflater.finish();</span>
<span class="nc" id="L1365">        int numCompressedBytes = deflater.deflate(deflated);</span>
<span class="nc" id="L1366">        deflater.reset();</span>
<span class="nc" id="L1367">        return numCompressedBytes;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>